# Fails or passes pipeline based on results and removes temporary folders
parameters:
  - name: createBugsForFailures # OPTIONAL: If the OWASP pipeline fails, have Azure DevOps create bug cards
    default: false
  - name: parentCardId # OPTIONAL: If 'createBugsForFailures' is true, provide a parent card number for any raised cards
    default: ''
  - name: organisationUri # OPTIONAL: The URI of the DevOps organisation to create the bugs in. Defaults to the current organisation.
    type: string
    default: '$(System.TeamFoundationCollectionUri)'
  - name: projectName # OPTIONAL: The name of the DevOps project to create the bugs in. Defaults to the current project.
    type: string
    default: '$(System.TeamProject)'

steps:
  # Create bug cards in DevOps if 'createBugsForFailures' is true
  - task: PowerShell@2
    displayName: 'Create Bug Cards for OWASP ZAP Failures'
    condition: and(succeeded(), eq('${{ parameters.createBugsForFailures }}', 'true'))
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      targetType: inline
      script: |
        filter ConvertTo-FoldedString { $_ -replace "\r?\n", " " }

        $organization = "${{parameters.organisationUri}}"
        $projectName = "${{parameters.projectName}}"
        $parentCardId = "${{parameters.parentCardId}}"

        az devops login --organization $organization --output none --access-token $env:SYSTEM_ACCESSTOKEN

        # Load the ZAP alerts from the Report XML
        $reportPath = "$(workingTempDirectory)/Report.xml"
        [xml]$zapReport = Get-Content -Path $reportPath

        $failedScenarios = $zapReport.OWASPZAPReport.site.alerts.alertitem

        # Loop through each failed scenario
        foreach ($scenario in $failedScenarios) {
          # Define a bug title in the format "Failing Scenario Name (Risk Level)"
          # Note: Sometimes the risk descriptions are duplicative e.g. "Medium (Medium)"
          $bugTitle = "OWASP Issue: $($scenario.name) $($scenario.riskdesc)"

          Write-Host ""
          Write-Host "Processing bug '$bugTitle'"

          # Query DevOps to check if this bug already exists in an active state
          $workItemQuery = @"
          SELECT [System.Id], [System.Title]
          FROM WorkItems
          WHERE
            [System.TeamProject] = '$projectName' AND
            [System.WorkItemType] = 'Bug' AND
            [System.State] <> 'Removed' AND
            [System.Title] CONTAINS 'OWASP Issue: $($scenario.name)'
        "@ | ConvertTo-FoldedString

          $queryExistingBugsResult = (az boards query `
            --organization $organization `
            --wiql $workItemQuery `
            --output json) | ConvertFrom-Json

          # If query returns with a count greater than 0, then do not create a duplicate bug
          if ($queryExistingBugsResult.Count -gt 0) {
            Write-Host "A bug already exists in the backlog"
          } else {
            Write-Host "No bug exists in the backlog"
            Write-Host "Creating a new bug"

            # Create a detailed description to be added to the cards AC
            $bugDetail = "<ol><li>This identified bug will be resolved, ensuring that the $($scenario.name) issue is no longer present in the codebase.<br>" +
              "Observed at: $($scenario.instances.instance.uri)<br>" +
              "OWASP Suggested Solution: $($scenario.solution)<br>" +
              "Resources: $($scenario.reference)</li></ol>"

            # Define the bug fields using the scenario data
            $fields = @(
              "AudaciaScrum.Notes=$($scenario.desc)"
              "Microsoft.VSTS.Common.AcceptanceCriteria=$($bugDetail)",
              "Microsoft.VSTS.TCM.ReproSteps=Evidence: $($scenario.instances.instance.evidence)"
            )

            # Create the bug
            $createResponse = (az boards work-item create `
              --organization $organization `
              --project $projectName `
              --title $bugTitle `
              --type "Bug" `
              --fields @fields `
              --output json) | ConvertFrom-Json

            if (!$createResponse) {
              Write-Warning "Failed to create bug"
              continue
            }

            # If a parent card has been provided, link as a parent to the bug
            if ($null -ne $parentCardId -and $parentCardId -ne "") {
              Write-Host "Linking to parent"

              $createLinkResponse = az boards work-item relation add `
                --organization $organization `
                --id $createResponse.id `
                --target-id $parentCard `
                --relation-type "Parent"

              if (!$createLinkResponse) {
                Write-Warning "Failed to link to parent"
              }
            }

            # Log out the created card
            Write-Host "A bug was created with the ID #$($createResponse.id)"
          }
        }

  # Fail if any of the scans railes alerts (and therefore have failed tests)
  - task: Bash@3
    inputs:
      targetType: 'inline'
      script: exit 1
    condition: and(succeeded(), eq(variables.alertsExist, 'true'))
    displayName: "Finalize: Fail Pipeline If Alerts Exist"

  # Delete the temporary directory created in setup.yaml as clean-up
  - task: DeleteFiles@1
    inputs:
      sourceFolder: $(parentWorkingTempDirectory)
      contents: '**/*'
      removeSourceFolder: true
    condition: always() # this step will always run, even if the pipeline is cancelled
    displayName: 'Finalize: Remove Temporary Directory'