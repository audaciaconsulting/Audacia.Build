parameters:
  - name: name
    type: string
    default: ''
  - name: targetUrl
    type: string
    default: ''
  - name: scanType
    type: string
    default: 'quick-scan'   # Accepts "quick-scan" or "API"
  - name: useAjaxSpider
    type: boolean
    default: 'false'
  - name: maxScanTime
    type: number
    default: '15'  # in minutes, for example
  - name: authorizationHeaderValue
    type: string
    default: ''  # used only for API scans
  - name: zapContextLocation
    type: string
    default: ''  # used only for API scans (for alert filters etc.)
  - name: createBugsForFailures
    type: boolean
    default: 'false'
  - name: parentCardId
    type: string
    default: ''
  - name: organisationUri
    type: string
    default: '$(System.TeamFoundationCollectionUri)'
  - name: projectName
    type: string
    default: '$(System.TeamProject)'

steps:
  # Verify that the initialize step has run (e.g. the parent working directory exists)
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Verify Initialization'
    inputs:
      targetType: 'inline'
      script: |
        if (-not (Test-Path -Path "$(parentWorkingTempDirectory)")) {
            throw "Initialization must be run before the scan. Please ensure initialize.yaml is included."
        }

  # Create a working directory for this scan
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Create Scan Working Directory'
    inputs:
      targetType: 'inline'
      script: |
        New-Item -Path "$(parentWorkingTempDirectory)" -Name "${{ parameters.name }}" -ItemType "directory"
        $NewDirectoryFullPath = "$(parentWorkingTempDirectory)/${{ parameters.name }}"
        Write-Host "##vso[task.setvariable variable=workingTempDirectory]$NewDirectoryFullPath"
        # Ensure the directory is writable so Docker can write into it
        chmod a+w "$NewDirectoryFullPath"
        Write-Output "Created working folder at $NewDirectoryFullPath"

  # Dynamically generate the zap-automation.yaml configuration file
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Generate ZAP Automation Config'
    inputs:
      targetType: 'inline'
      script: |
        # Convert the useAjaxSpider boolean parameter to a lowercase string for YAML
        if ('${{ parameters.useAjaxSpider }}' -eq 'True') {
            $ajaxValue = "true"
        } else {
            $ajaxValue = "false"
        }
        
        # Build the action block based on the scanType.
        if ('${{ parameters.scanType }}' -eq 'API') {
            $actionBlock = @(
                "  - type: api-scan",
                "    parameters:",
                "      contextName: 'APIContext'",
                "      authorizationHeaderValue: '${{ parameters.authorizationHeaderValue }}'",
                "      zapContextLocation: '${{ parameters.zapContextLocation }}'",
                "      maxScanTime: ${{ parameters.maxScanTime }}"
            )
        } else {
            $actionBlock = @(
                "  - type: quick-scan",
                "    parameters:",
                "      target: '${{ parameters.targetUrl }}'",
                "      useAjaxSpider: $ajaxValue",
                "      maxScanTime: ${{ parameters.maxScanTime }}"
            )
        }
        
        # Build the configuration in the order recommended by the documentation.
        $configLines = @(
            "# ZAP Automation Framework configuration (dynamically generated)",
            "version: '2.0'"
        )
        
        # First, build the environment block.
        if ('${{ parameters.scanType }}' -eq 'API') {
            $envBlock = @(
                "env:",
                "  targetUrl: '${{ parameters.targetUrl }}'",
                "  contexts:",
                "    - APIContext"
            )
        } else {
            $envBlock = @(
                "env:",
                "  targetUrl: '${{ parameters.targetUrl }}'"
            )
        }
        $configLines += $envBlock
        
        # For API scans, add the top-level contexts block next.
        if ('${{ parameters.scanType }}' -eq 'API') {
            $contextsBlock = @(
                "contexts:",
                "  - name: APIContext",
                "    urls:",
                "      - '${{ parameters.targetUrl }}'"
            )
            $configLines += $contextsBlock
        }
        
        # Append the actions and reports sections.
        $configLines += @("actions:") + $actionBlock + @(
            "reports:",
            "  - type: html",
            "    fileName: Report.html",
            "  - type: xml",
            "    fileName: Report.xml"
        )
        
        # Join the lines with newline characters and write the configuration file.
        $configContent = $configLines -join "`n"
        $configFilePath = "$(workingTempDirectory)/zap-automation.yaml"
        $configContent | Out-File -FilePath $configFilePath -Encoding UTF8
        Write-Output "Generated zap-automation.yaml at $configFilePath"

  # Option 1: Publish the generated configuration file as a build artifact
  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish ZAP Automation Config Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/zap-automation.yaml'
      artifactName: 'zap-automation-config'
      publishLocation: 'Container'

  # Option 2: Log the configuration file for debugging purposes
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Log ZAP Automation Config'
    inputs:
      targetType: 'inline'
      script: |
        Write-Output "Contents of zap-automation.yaml:"
        Get-Content "$(workingTempDirectory)/zap-automation.yaml" | Write-Output

  - task: Bash@3
    displayName: 'Debug: List mounted directory'
    inputs:
      targetType: 'inline'
      script: |
        docker run --rm --mount type=bind,source="$(workingTempDirectory)",target=/zap -w /zap alpine ls -l /zap

  - task: Bash@3
    displayName: 'Debug: Find zap.sh location'
    inputs:
      targetType: 'inline'
      script: |
        docker run --rm ghcr.io/zaproxy/zaproxy:stable sh -c "find / -name zap.sh 2>/dev/null || true"
  
  # Run the OWASP ZAP Automation scan via Docker
  - task: Bash@3
    displayName: '${{ parameters.name }}: Run OWASP ZAP Automation Scan'
    inputs:
      targetType: 'inline'
      script: |
        # Mount the working directory to /zap/wrk, then run zap.sh from /zap using the config file in /zap/wrk.
        docker run --rm --mount type=bind,source="$(workingTempDirectory)",target=/zap/wrk -w /zap ghcr.io/zaproxy/zaproxy:stable /zap/zap.sh -cmd -autorun /zap/wrk/zap-automation.yaml

  # Transform the XML report to NUnit format so that alerts appear as test cases in DevOps.
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Transform XML Report to NUnit Format'
    inputs:
      targetType: 'inline'
      script: |
        $XslPath = "$(parentWorkingTempDirectory)/OWASPToNUnit3.xslt"
        $XmlInputPath = "$(workingTempDirectory)/Report.xml"
        $XmlOutputPath = "$(workingTempDirectory)/NUnit-Report.xml"
        $XslTransform = New-Object System.Xml.Xsl.XslCompiledTransform
        $XslTransform.Load($XslPath)
        Write-Output "Transforming Report.xml into NUnit-Report.xml"
        $XslTransform.Transform($XmlInputPath, $XmlOutputPath)

  # Create bug work items if configured (reusing your existing create-bugs template)
  - ${{ if eq(parameters.createBugsForFailures, true) }}:
      - template: ./create-bugs.yaml
        parameters:
          parentCardId: ${{ parameters.parentCardId }}
          organisationUri: ${{ parameters.organisationUri }}
          projectName: ${{ parameters.projectName }}
          name: ${{ parameters.name }}

  # Publish the raw XML and HTML reports as build artifacts
  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish XML Report Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/Report.xml'
      artifactName: '${{ parameters.name }}-XML'
      publishLocation: 'Container'

  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish HTML Report Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/Report.html'
      artifactName: '${{ parameters.name }}-HTML'
      publishLocation: 'Container'

  # Publish the transformed report as test results so that alerts are visible as test failures
  - task: PublishTestResults@2
    displayName: '${{ parameters.name }}: Publish Scan Results as Test Results'
    inputs:
      testRunTitle: '${{ parameters.name }}'
      testRunner: 'NUnit'
      testResultsFiles: '**/NUnit-Report.xml'
      searchFolder: '$(workingTempDirectory)'
      publishRunAttachments: false

  # Set the alerts flag if any non-false-positive alerts exist (parsing Report.xml)
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Set Alerts Exist Flag If Required'
    inputs:
      targetType: 'inline'
      script: |
        $Alerts = Select-Xml -Path "$(workingTempDirectory)/Report.xml" -XPath "//*[local-name()='alertitem'][not(.//confidence='0')]"
        if ($Alerts.Count -gt 0) {
            Write-Output "Alerts detected; setting alertsExist variable to true."
            Write-Host "##vso[task.setvariable variable=alertsExist]true"
        }
    condition: and(succeeded(), ne(variables.alertsExist, 'true'))
