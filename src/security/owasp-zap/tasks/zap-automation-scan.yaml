parameters:
  - name: name
    type: string
    default: ''
  - name: targetUrl
    type: string
    default: ''
  - name: scanType
    type: string
    default: 'quick-scan'   # Allowed values: "quick-scan" or "API"
  - name: maxScanTime
    type: number
    default: '15'  # in minutes
  - name: authorizationHeaderValue
    type: string
    default: ''  # Used for API scans; if empty, the JWT access token will be used
  - name: createBugsForFailures
    type: boolean
    default: 'false'
  - name: parentCardId
    type: string
    default: ''
  - name: organisationUri
    type: string
    default: '$(System.TeamFoundationCollectionUri)'
  - name: projectName
    type: string
    default: '$(System.TeamProject)'
  - name: deleteGlobalAlerts         # New parameter to control deletion of global alerts.
    type: boolean
    default: false
  - name: alertFilters               # New parameter to pass a list of alert filters.
    type: object
    default: []

steps:
  # Verify that the initialization step has run.
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Verify Initialization'
    inputs:
      targetType: 'inline'
      script: |
        if (-not (Test-Path -Path "$(parentWorkingTempDirectory)")) {
          throw "Initialization must be run before the scan. Please ensure initialize.yaml is included."
        }

  # Create a working directory for this scan.
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Create Scan Working Directory'
    inputs:
      targetType: 'inline'
      script: |
        New-Item -Path "$(parentWorkingTempDirectory)" -Name "${{ parameters.name }}" -ItemType "directory"
        $NewDirectoryFullPath = "$(parentWorkingTempDirectory)/${{ parameters.name }}"
        Write-Host "##vso[task.setvariable variable=workingTempDirectory]$NewDirectoryFullPath"
        chmod a+w "$NewDirectoryFullPath"
        Write-Output "Created working folder at $NewDirectoryFullPath"

  # Dynamically generate the ZAP Automation Framework configuration file.
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Generate ZAP Automation Config'
    env:
      ALERTFILTERS_JSON: $[toJson(parameters.alertFilters)]
      DELETE_GLOBAL_ALERTS: $[parameters.deleteGlobalAlerts]
    inputs:
      targetType: 'inline'
      script: |
        # Determine the base URL. If the targetUrl contains '/swagger', remove that portion.
        $target = '${{ parameters.targetUrl }}'
        if ($target -match "/swagger") {
            $baseUrl = $target -replace "/swagger.*", ""
        } else {
            $baseUrl = $target
        }
        
        # Initialize alert filters if provided.
        $alertFiltersJson = $env:ALERTFILTERS_JSON
        if ($alertFiltersJson -and $alertFiltersJson -ne '[]' -and $alertFiltersJson -ne 'null') {
            $alertFilters = $alertFiltersJson | ConvertFrom-Json
        } else {
            $alertFilters = @()
        }
        $deleteGlobalAlerts = $env:DELETE_GLOBAL_ALERTS
        
        # Begin building the configuration file content.
        $configContent = @()
        $configContent += "---"
        $configContent += "env:"
        # For API scans with a bearer token, add the token as a global HTTP header.
        if ('${{ parameters.scanType }}' -eq 'API' -and '${{ parameters.authorizationHeaderValue }}' -ne '') {
            $configContent += "  httpHeaders:"
            $configContent += "  - name: Authorization"
            $configContent += "    value: '${{ parameters.authorizationHeaderValue }}'"
        }
        $configContent += "  contexts:"
        $configContent += "  - name: 'Authentication Test'"
        $configContent += "    urls:"
        $configContent += "    - '$baseUrl'"
        $configContent += "    includePaths:"
        $configContent += "    - '$baseUrl.*'"
        $configContent += "    excludePaths: []"
        if ('${{ parameters.scanType }}' -ne 'API') {
            $configContent += "    authentication:"
            $configContent += "      method: 'browser'"
            $configContent += "      parameters:"
            $configContent += "        loginPageUrl: '$baseUrl/Account/Login?ReturnUrl=%2Fconnect%2Fauthorize...'"
            $configContent += "        loginPageWait: 2"
            $configContent += "        browserId: 'firefox'"
            $configContent += "    verification:"
            $configContent += "      method: 'poll'"
            $configContent += "      loggedInRegex: '\\Q 200 OK\\E'"
            $configContent += "      loggedOutRegex: '\\Q 401 Unauthorized\\E'"
            $configContent += "      pollFrequency: 60"
            $configContent += "      pollUnits: 'requests'"
            $configContent += "      pollUrl: '$baseUrl/connect/userinfo'"
            $configContent += "      pollPostData: ''"
            $configContent += "      pollAdditionalHeaders:"
            $configContent += "      - header: 'content-type'"
            $configContent += "        value: 'application/x-www-form-urlencoded'"
        }
        $configContent += "    sessionManagement:"
        $configContent += "      method: 'headers'"
        $configContent += "      parameters:"
        $configContent += "        Cookie: '.AspNetCore.Antiforgery.cdV5uW_Ejgc={%cookie:.AspNetCore.Antiforgery.cdV5uW_Ejgc%}; ARRAffinity=REDACTED; ARRAffinitySameSite=REDACTED'"
        $configContent += "    technology:"
        $configContent += "      exclude: []"
        $configContent += "  parameters:"
        $configContent += "    failOnError: true"
        $configContent += "    failOnWarning: false"
        $configContent += "    progressToStdout: true"
        $configContent += "  vars: {}"
        $configContent += "jobs:"
        $configContent += "  - parameters:"
        $configContent += "      scanOnlyInScope: true"
        $configContent += "      enableTags: false"
        $configContent += "      disableAllRules: false"
        $configContent += "    rules: []"
        $configContent += "    name: 'passiveScan-config'"
        $configContent += "    type: 'passiveScan-config'"
        $configContent += "  - parameters: {}"
        $configContent += "    name: 'spider'"
        $configContent += "    type: 'spider'"
        $configContent += "    tests:"
        $configContent += "    - onFail: 'INFO'"
        $configContent += "      statistic: 'automation.spider.urls.added'"
        $configContent += "      site: ''"
        $configContent += "      operator: '>='"
        $configContent += "      value: 100"
        $configContent += "      type: 'stats'"
        $configContent += "      name: 'At least 100 URLs found'"
        $configContent += "  - parameters:"
        $configContent += "      maxDuration: ${{ parameters.maxScanTime }}"
        $configContent += "      maxCrawlDepth: 10"
        $configContent += "      numberOfBrowsers: 32"
        $configContent += "      inScopeOnly: true"
        $configContent += "    name: 'spiderAjax'"
        $configContent += "    type: 'spiderAjax'"
        $configContent += "    tests:"
        $configContent += "    - onFail: 'INFO'"
        $configContent += "      statistic: 'spiderAjax.urls.added'"
        $configContent += "      site: ''"
        $configContent += "      operator: '>='"
        $configContent += "      value: 100"
        $configContent += "      type: 'stats'"
        $configContent += "      name: 'At least 100 URLs found'"
        $configContent += "  - parameters: {}"
        $configContent += "    name: 'passiveScan-wait'"
        $configContent += "    type: 'passiveScan-wait'"
        $configContent += "  - parameters: {}"
        $configContent += "    name: 'activeScan'"
        $configContent += "    type: 'activeScan'"
        $configContent += "    policyDefinition: {}"
        
        # Insert the alertFilter job if any alert filters are provided.
        if ($alertFilters.Count -gt 0) {
            $configContent += "  - type: 'alertFilter'"
            $configContent += "    parameters:"
            $configContent += "      deleteGlobalAlerts: $deleteGlobalAlerts"
            $configContent += "    alertFilters:"
            foreach ($filter in $alertFilters) {
                $configContent += "      - ruleId: $($filter.ruleId)"
                $configContent += "        newRisk: '$($filter.newRisk)'"
                $configContent += "        context: '$($filter.context)'"
                $configContent += "        url: '$($filter.url)'"
                $configContent += "        urlRegex: $($filter.urlRegex)"
                $configContent += "        parameter: '$($filter.parameter)'"
                $configContent += "        parameterRegex: $($filter.parameterRegex)"
                $configContent += "        attack: '$($filter.attack)'"
                $configContent += "        attackRegex: $($filter.attackRegex)"
                $configContent += "        evidence: '$($filter.evidence)'"
                $configContent += "        evidenceRegex: $($filter.evidenceRegex)"
            }
        }
        
        $configContent += "  - type: 'exitStatus'"
        $configContent += "    parameters: {}"
        $configContent += "  - parameters:"
        $configContent += "      template: 'traditional-xml-plus'"
        $configContent += "      reportTitle: 'ZAP Scanning Report'"
        $configContent += "      reportDescription: ''"
        $configContent += "    name: 'reportXml'"
        $configContent += "    type: 'report'"
        $configContent += "  - parameters:"
        $configContent += "      template: 'traditional-html-plus'"
        $configContent += "      reportTitle: 'ZAP Scanning Report'"
        $configContent += "      reportDescription: ''"
        $configContent += "    name: 'reportHtml'"
        $configContent += "    type: 'report'"
        
        $configFilePath = "$(workingTempDirectory)/zap-automation.yaml"
        $finalConfig = $configContent -join "`n"
        $finalConfig | Out-File -FilePath $configFilePath -Encoding UTF8
        Write-Output "Generated zap-automation.yaml at $configFilePath"
        Write-Output "Configuration content:"
        Write-Output $finalConfig

  # Publish the generated configuration file as a build artifact.
  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish ZAP Automation Config Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/zap-automation.yaml'
      artifactName: 'zap-automation-config'
      publishLocation: 'Container'

  # Run the OWASP ZAP Automation scan via Docker.
  - task: Bash@3
    displayName: '${{ parameters.name }}: Run OWASP ZAP Automation Scan'
    inputs:
      targetType: 'inline'
      script: |
        docker run --rm --mount type=bind,source="$(workingTempDirectory)",target=/zap/wrk -w /zap ghcr.io/zaproxy/zaproxy:stable /zap/zap.sh -cmd -autorun /zap/wrk/zap-automation.yaml

  # Rename the generated report files to fixed names.
  - task: PowerShell@2
    displayName: 'Rename ZAP XML Report'
    inputs:
      targetType: 'inline'
      script: |
        $xmlFiles = Get-ChildItem -Path "$(workingTempDirectory)" -Recurse -Filter "*ZAP-Report*.xml"
        if ($xmlFiles.Count -eq 0) {
            Write-Error "No ZAP XML report file was found."
            exit 1
        }
        $xmlReport = $xmlFiles[0].FullName
        Write-Output "Found XML report file: $xmlReport"
        $destXml = Join-Path "$(workingTempDirectory)" "Report.xml"
        Copy-Item -Path $xmlReport -Destination $destXml -Force
        Write-Output "Renamed XML report file to: $destXml"

  - task: PowerShell@2
    displayName: 'Rename ZAP HTML Report'
    inputs:
      targetType: 'inline'
      script: |
        $htmlFiles = Get-ChildItem -Path "$(workingTempDirectory)" -Recurse -Filter "*ZAP-Report*.html"
        if ($htmlFiles.Count -eq 0) {
            Write-Error "No ZAP HTML report file was found."
            exit 1
        }
        $htmlReport = $htmlFiles[0].FullName
        Write-Output "Found HTML report file: $htmlReport"
        $destHtml = Join-Path "$(workingTempDirectory)" "Report.html"
        Copy-Item -Path $htmlReport -Destination $destHtml -Force
        Write-Output "Renamed HTML report file to: $destHtml"

  # Transform the XML report to NUnit format so that alerts appear as test cases in DevOps.
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Transform XML Report to NUnit Format'
    inputs:
      targetType: 'inline'
      script: |
        $XslPath = "$(parentWorkingTempDirectory)/OWASPToNUnit3.xslt"
        $XmlInputPath = "$(workingTempDirectory)/Report.xml"
        $XmlOutputPath = "$(workingTempDirectory)/NUnit-Report.xml"
        $XslTransform = New-Object System.Xml.Xsl.XslCompiledTransform
        Write-Output "Transforming Report.xml into NUnit-Report.xml"
        $XslTransform.Load($XslPath)
        $XslTransform.Transform($XmlInputPath, $XmlOutputPath)

  # Create bug work items if configured.
  - ${{ if eq(parameters.createBugsForFailures, true) }}:
      - template: ./create-bugs.yaml
        parameters:
          parentCardId: ${{ parameters.parentCardId }}
          organisationUri: ${{ parameters.organisationUri }}
          projectName: ${{ parameters.projectName }}
          name: ${{ parameters.name }}

  # Publish the raw XML and HTML reports as build artifacts.
  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish XML Report Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/Report.xml'
      artifactName: '${{ parameters.name }}-XML'
      publishLocation: 'Container'

  - task: PublishBuildArtifacts@1
    displayName: '${{ parameters.name }}: Publish HTML Report Artifact'
    inputs:
      pathtoPublish: '$(workingTempDirectory)/Report.html'
      artifactName: '${{ parameters.name }}-HTML'
      publishLocation: 'Container'

  # Publish the transformed report as test results so that alerts are visible as test failures.
  - task: PublishTestResults@2
    displayName: '${{ parameters.name }}: Publish Scan Results as Test Results'
    inputs:
      testRunTitle: '${{ parameters.name }}'
      testRunner: 'NUnit'
      testResultsFiles: '**/NUnit-Report.xml'
      searchFolder: '$(workingTempDirectory)'
      publishRunAttachments: false

  # Set the alerts flag if any non-false-positive alerts exist (parsing Report.xml).
  - task: PowerShell@2
    displayName: '${{ parameters.name }}: Set Alerts Exist Flag If Required'
    inputs:
      targetType: 'inline'
      script: |
        $Alerts = Select-Xml -Path "$(workingTempDirectory)/Report.xml" -XPath "//*[local-name()='alertitem'][not(.//confidence='0')]"
        if ($Alerts.Count -gt 0) {
          Write-Output "Alerts detected; setting alertsExist variable to true."
          Write-Host "##vso[task.setvariable variable=alertsExist]true"
        }
    condition: and(succeeded(), ne(variables.alertsExist, 'true'))
