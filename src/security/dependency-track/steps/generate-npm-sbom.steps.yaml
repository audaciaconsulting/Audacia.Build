# Template: generate npm SBOMs using cyclonedx-npm
# Behaviour:
# - If npmrcPaths (multiline) is provided, authenticate EACH .npmrc in place via npmAuthenticate@0.
# - No aggregation or shared combined .npmrc file is used.

parameters:
  # One or more directories that contain a package.json. Accepts a single string or a multiline string.
  # Paths may be repo-relative or absolute. Mixed separators are normalized and each entry is validated.
  - name: npmRoots
    type: string
    default: ''

  # Node.js version spec understood by UseNode (e.g., "22.x"). The major version is resolved on the hosted agent.
  - name: nodeVersion
    type: string
    default: '22.x'

  # When true, runs a clean installation and gathers license texts. Produces richer SBOMs at the cost of time and artifact size.
  - name: includeLicenseTexts
    type: boolean
    default: true

  # Publish the SBOM output from this step. Set false when combining with .NET to publish once later.
  - name: publishArtifact
    type: boolean
    default: false

  # Logical name for the pipeline artifact when publishing is enabled.
  - name: artifactName
    type: string
    default: 'sbom-files'

  # Optional: one or more .npmrc paths as a multiline string (consistent with npmRoots).
  # Example:
  #   npmrcPaths: |
  #     $(System.DefaultWorkingDirectory)/src/app-one/.npmrc
  #     $(System.DefaultWorkingDirectory)/src/app-two/.npmrc
  - name: npmrcPaths
    type: string
    default: ''

steps:
  - task: UseNode@1
    displayName: Use Node.js ${{ parameters.nodeVersion }}
    inputs:
      versionSpec: ${{ parameters.nodeVersion }}
      checkLatest: false

  # Resolve .npmrc paths (from multiline string) and expose up to 6 indexed variables.
  # Increase MAX_SLOTS if you ever need more.
  - task: PowerShell@2
    name: resolveNpmrcPaths
    displayName: "Resolve .npmrc paths (from multiline)"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $MAX_SLOTS = 6

        $npmrcMultilineLiteral = @'
        ${{ parameters.npmrcPaths }}
        '@

        $workspaceRoot = $env:SYSTEM_DEFAULTWORKINGDIRECTORY
        if (-not $workspaceRoot -or [string]::IsNullOrWhiteSpace($workspaceRoot)) {
          $workspaceRoot = $env:BUILD_SOURCESDIRECTORY
        }
        $workspaceRootFull = [IO.Path]::GetFullPath($workspaceRoot)

        function Normalize-Path([string]$pathText, [string]$baseRoot) {
          if (-not $pathText) { return $null }
          $p = ($pathText -replace '/', '\').Trim().Trim('"')
          $p = $p -replace '\$\((?i:Build\.SourcesDirectory|System\.DefaultWorkingDirectory)\)', $baseRoot
          if ([IO.Path]::IsPathRooted($p)) { return [IO.Path]::GetFullPath($p) }
          return [IO.Path]::GetFullPath((Join-Path $baseRoot $p))
        }

        $entries = @()
        if (-not [string]::IsNullOrWhiteSpace($npmrcMultilineLiteral)) {
          $entries = $npmrcMultilineLiteral -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
        }

        $resolvedExisting = New-Object System.Collections.Generic.List[string]
        foreach ($entry in $entries) {
          $full = Normalize-Path $entry $workspaceRootFull
          if (-not $full) { continue }
          if (Test-Path -LiteralPath $full) {
            if (-not ($resolvedExisting -contains $full)) { $resolvedExisting.Add($full) }
          } else {
            Write-Warning "Provided .npmrc path not found: $entry → $full"
          }
        }

        $count = [Math]::Min($resolvedExisting.Count, $MAX_SLOTS)
        Write-Host "Resolved $($resolvedExisting.Count) valid .npmrc file(s); exposing up to $count slot(s)."

        # Clear all slots first
        for ($i=1; $i -le $MAX_SLOTS; $i++) {
          Write-Host "##vso[task.setvariable variable=npmrcPath_$i;isOutput=true]"
        }

        for ($i=1; $i -le $count; $i++) {
          $val = $resolvedExisting[$i-1]
          Write-Host "Slot $i -> $val"
          Write-Host "##vso[task.setvariable variable=npmrcPath_$i;isOutput=true]$val"
        }

        Write-Host "##vso[task.setvariable variable=npmrcCount;isOutput=true]$count"

  # Authenticate each .npmrc individually (no combined file)
  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #1"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_1'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_1)"

  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #2"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_2'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_2)"

  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #3"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_3'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_3)"

  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #4"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_4'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_4)"

  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #5"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_5'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_5)"

  - task: npmAuthenticate@0
    displayName: "Authenticate npm via .npmrc #6"
    condition: and(succeeded(), ne(variables['resolveNpmrcPaths.npmrcPath_6'], ''))
    inputs:
      workingFile: "$(resolveNpmrcPaths.npmrcPath_6)"

  - task: PowerShell@2
    displayName: "Setup Node.js tooling and expose paths"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        function Get-NodeToolPaths {
          param([string]$majorVersion)
          $toolsRoot = Join-Path $env:AGENT_TOOLSDIRECTORY 'node'
          if (-not (Test-Path $toolsRoot)) { throw "Node tools directory not found: $toolsRoot" }
          $matchedVersion = Get-ChildItem $toolsRoot -Directory -Name | Where-Object { $_ -like "$majorVersion.*" } | Sort-Object { [version]$_ } -Descending | Select-Object -First 1
          if (-not $matchedVersion) { throw "No Node $majorVersion.* found under $toolsRoot" }
          $binDirectory = Join-Path (Join-Path $toolsRoot $matchedVersion) 'x64'
          $nodeExe = Join-Path $binDirectory 'node.exe'
          $npmCmd  = Join-Path $binDirectory 'npm.cmd'
          $npxCmd  = Join-Path $binDirectory 'npx.cmd'
          if (-not (Test-Path $nodeExe)) { throw "node.exe not found at $nodeExe" }
          if (-not (Test-Path $npmCmd))  { throw "npm.cmd not found at $npmCmd" }
          if (-not (Test-Path $npxCmd))  { throw "npx.cmd not found at $npxCmd" }
          [pscustomobject]@{ Node=$nodeExe; Npm=$npmCmd; Npx=$npxCmd; Bin=$binDirectory; Version=$matchedVersion }
        }

        $requestedSpec='${{ parameters.nodeVersion }}'
        $majorVersion = [regex]::Match($requestedSpec, '^\d+').Value
        if (-not $majorVersion) { throw "Could not derive Node major version from spec: '$requestedSpec'." }
        $nodeTooling = Get-NodeToolPaths -majorVersion $majorVersion

        Write-Host "##[group]Node tooling (resolved)"
        & $nodeTooling.Node --version
        & $nodeTooling.Npm  --version
        & $nodeTooling.Npx  --version
        Write-Host "Resolved bin: $($nodeTooling.Bin)"
        Write-Host "##[endgroup]"

        Write-Host "##vso[task.prependpath]$($nodeTooling.Bin)"
        $env:PATH = "$($nodeTooling.Bin);$env:PATH"
        Write-Host "##vso[task.setvariable variable=SBOM_NODE_BIN]$($nodeTooling.Bin)"
        Write-Host "##vso[task.setvariable variable=SBOM_NODE]$($nodeTooling.Node)"
        Write-Host "##vso[task.setvariable variable=SBOM_NPM]$($nodeTooling.Npm)"
        Write-Host "##vso[task.setvariable variable=SBOM_NPX]$($nodeTooling.Npx)"

  - task: PowerShell@2
    name: resolveNpmRoots
    displayName: "Validate npm project roots"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'

        $rootsMultilineLiteral = @'
        ${{ parameters.npmRoots }}
        '@

        $inputRootEntries = @()
        if (-not [string]::IsNullOrWhiteSpace($rootsMultilineLiteral)) {
          $inputRootEntries = $rootsMultilineLiteral -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
        }

        if ($inputRootEntries.Count -eq 0) {
          throw "No package.json file-paths were provided. Provide one or more explicit directories that contain package.json."
        }

        $workspaceRoot = $env:SYSTEM_DEFAULTWORKINGDIRECTORY
        if (-not $workspaceRoot -or [string]::IsNullOrWhiteSpace($workspaceRoot)) {
          $workspaceRoot = $env:BUILD_SOURCESDIRECTORY
        }
        $workspaceRootFull = [IO.Path]::GetFullPath($workspaceRoot)

        function Convert-ToRelativeIfUnderRoot([string]$pathEntry, [string]$rootPath) {
          $resolvedFullPath = [IO.Path]::GetFullPath($pathEntry)
          if ($resolvedFullPath.StartsWith($rootPath, [System.StringComparison]::OrdinalIgnoreCase)) {
            return $resolvedFullPath.Substring($rootPath.Length).TrimStart('\')
          }
          return $resolvedFullPath
        }

        $validatedRelativeRoots = New-Object System.Collections.Generic.List[string]

        foreach ($rootEntry in $inputRootEntries) {
          if ([string]::IsNullOrWhiteSpace($rootEntry)) { continue }
          $normalizedEntry = ($rootEntry -replace '/', '\').Trim().Trim('"').Trim()

          $normalizedEntry = $normalizedEntry -replace '\$\((?i:Build\.SourcesDirectory|System\.DefaultWorkingDirectory)\)', $workspaceRootFull
          try { $relativePath = Convert-ToRelativeIfUnderRoot -pathEntry $normalizedEntry -rootPath $workspaceRootFull } catch { $relativePath = $normalizedEntry }

          $relativeOrDot = if ([string]::IsNullOrWhiteSpace($relativePath)) { '.' } else { $relativePath }
          $absolutePath = if ([System.IO.Path]::IsPathRooted($relativePath)) { $relativePath } else { Join-Path $workspaceRootFull $relativePath }

          $packageJsonPath = Join-Path $absolutePath 'package.json'
          if (-not (Test-Path -LiteralPath $packageJsonPath)) {
            throw "Invalid npm root: '$rootEntry' → '$relativePath'. Expected file not found: package.json"
          }

          if (-not ($validatedRelativeRoots -contains $relativeOrDot)) {
            $validatedRelativeRoots.Add($relativeOrDot)
          }
        }

        if ($validatedRelativeRoots.Count -eq 0) {
          throw "Validation produced an empty list of npm roots. Ensure you pass directories that contain package.json."
        }

        Write-Host "##[group]Validated npm roots"
        $validatedRelativeRoots | ForEach-Object { Write-Host $_ }
        Write-Host "##[endgroup]"

        $rootsArray = @()
        $rootsArray += $validatedRelativeRoots.ToArray()

        $absoluteRootsForLog = $rootsArray | ForEach-Object {
          if ([System.IO.Path]::IsPathRooted($_)) { $_ } else { Join-Path $workspaceRootFull $_ }
        }

        $rootsJson = ($rootsArray | ConvertTo-Json -Compress)
        Write-Host "##vso[task.setvariable variable=npmRootsJson;isOutput=true]$rootsJson"
        Write-Host "Resolved npm roots JSON: $rootsJson"
        Write-Host "Resolved absolute path(s):"
        $absoluteRootsForLog | ForEach-Object { Write-Host " - $_" }

  - task: PowerShell@2
    displayName: "Generate npm SBOMs (CycloneDX, JSON)"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'

        New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/sbom" -Force | Out-Null
        New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/sbom/npm" -Force | Out-Null

        if ($env:SBOM_NODE_BIN) { $env:PATH = "$env:SBOM_NODE_BIN;$env:PATH" }
        npm config set cache "$(Pipeline.Workspace)/.npm" --global | Out-Null

        $validatedRootsJson = '$(resolveNpmRoots.npmRootsJson)'
        $npmProjectRootList = @()
        try { $npmProjectRootList = $validatedRootsJson | ConvertFrom-Json } catch { $npmProjectRootList=@() }

        if (-not $npmProjectRootList -or $npmProjectRootList.Count -eq 0) {
          throw "No npm project roots available after validation. This step requires explicit directories containing package.json."
        }

        $includeLicenseTexts = "${{ parameters.includeLicenseTexts }}" -eq "True"
        $outputFormat = 'json'
        $outputExtension = 'json'
        $successCount = 0
        $failureCount = 0

        foreach ($projectRoot in $npmProjectRootList) {
          $absoluteProjectPath = if ([System.IO.Path]::IsPathRooted($projectRoot)) { $projectRoot } else { Join-Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY $projectRoot }
          $packageJsonPath  = Join-Path $absoluteProjectPath 'package.json'
          $packageLockPath = Join-Path $absoluteProjectPath 'package-lock.json'

          if (-not (Test-Path -LiteralPath $packageJsonPath)) {
            throw "package.json is required but was not found at: $packageJsonPath"
          }

          $folderName = Split-Path $absoluteProjectPath -Leaf
          if ([string]::IsNullOrWhiteSpace($folderName)) { $folderName = 'app' }
          $safeFolderName = ($folderName -replace '[<>:"/\\|?*]', '-').Trim().TrimEnd('.',' ')
          $outputDir = Join-Path "$(Agent.TempDirectory)/sbom/npm" $safeFolderName
          New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
          $outputFile = Join-Path $outputDir "$safeFolderName-sbom.$outputExtension"

          $locationLabel = $absoluteProjectPath
          if ($projectRoot -eq '.') { $locationLabel = "$absoluteProjectPath (repo root)" }
          Write-Host "##[group]JS SBOM → $locationLabel"
          Push-Location $absoluteProjectPath
          try {
            $hasPackageLock = Test-Path -LiteralPath $packageLockPath
            if (-not $hasPackageLock) {
              npm install --package-lock-only --ignore-scripts --no-audit --no-fund
              $hasPackageLock = Test-Path -LiteralPath $packageLockPath
              if (-not $hasPackageLock) { throw "Failed to create package-lock.json in '$absoluteProjectPath'" }
            }

            if ($includeLicenseTexts) {
              npm ci --ignore-scripts --no-audit --no-fund --no-progress
            }

            $cyclonedxArgs = @('--output-format', $outputFormat, '--output-file', $outputFile)
            if ($includeLicenseTexts) { $cyclonedxArgs += @('--gather-license-texts') }
            if (-not $includeLicenseTexts -and $hasPackageLock) { $cyclonedxArgs += @('--package-lock-only') }

            npx --yes -p @cyclonedx/cyclonedx-npm@4 cyclonedx-npm @cyclonedxArgs
            if (Test-Path $outputFile) { $successCount++ } else { $failureCount++ }
          } catch {
            Write-Warning "cyclonedx-npm failed: $($_.Exception.Message)"; $failureCount++
          } finally {
            Pop-Location | Out-Null
            Write-Host "Output: $outputFile"
            Write-Host "##[endgroup]"
          }
        }

        Write-Host "##[section]npm summary → ok=$successCount, failed=$failureCount"
        if ($failureCount -gt 0) { Write-Host "##vso[task.logissue type=warning]Some JS SBOMs failed"; exit 1 }

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: "Publish SBOM artifact"
        inputs:
          targetPath: "$(Agent.TempDirectory)/sbom"
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
