# Template: deactivate all non-latest active versions (optionally scoping by env tag)
parameters:
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: tryDownloadArtifact
    type: boolean
    default: true

steps:
  - checkout: none

  - ${{ if eq(parameters.tryDownloadArtifact, true) }}:
      - task: DownloadPipelineArtifact@2
        displayName: "Try to download SBOM artifact (optional)"
        inputs:
          artifact: ${{ parameters.artifactName }}
          path: $(Agent.TempDirectory)/sbom
          buildType: current
        continueOnError: true
        condition: always()

  - task: PowerShell@2
    displayName: "Deactivate non-latest versions in Dependency-Track"
    env:
      DT_API_URL: $(DT_API_URL)
      DT_API_KEY: $(DT_API_KEY)
      ENV_NAME: $(ENV_NAME)
      ADDITIONAL_TAGS: $(ADDITIONAL_TAGS)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'

        # ---- Guard: ensure API URL/KEY are set ----
        if ([string]::IsNullOrWhiteSpace($env:DT_API_URL) -or [string]::IsNullOrWhiteSpace($env:DT_API_KEY)) {
          throw "DT_API_URL and/or DT_API_KEY not set. Check the 'Dependency-Track' variable group."
        }
        $base = "$($env:DT_API_URL)".TrimEnd('/')
        Write-Host "Using Dependency-Track API base: $base"

        function Derive-ProjectNamesFromSboms([string]$root) {
          $names = New-Object System.Collections.Generic.List[string]
          if (-not (Test-Path $root)) { return @() }
          $files = Get-ChildItem -Path $root -Recurse -Filter *.json -File -EA SilentlyContinue
          foreach ($f in $files) {
            try {
              $name = (Get-Content -Raw -LiteralPath $f.FullName | ConvertFrom-Json -ea Stop).metadata.component.name
              if ($name) { $names.Add($name) }
            } catch { }
          }
          return ($names | Select-Object -Unique)
        }

        Add-Type -AssemblyName System.Net.Http
        $http = [System.Net.Http.HttpClient]::new()
        $http.Timeout = [TimeSpan]::FromMinutes(10)
        $http.DefaultRequestHeaders.Add('X-Api-Key', $env:DT_API_KEY)

        function Invoke-DtApi([string]$method, [string]$path, [object]$body=$null) {
          $uri  = "$base$path"
          $msg  = New-Object System.Net.Http.HttpRequestMessage($method, $uri)
          if ($body -ne $null) {
            $json = $body | ConvertTo-Json -Depth 8
            $msg.Content = New-Object System.Net.Http.StringContent($json, [Text.Encoding]::UTF8, 'application/json')
          }
          $msg.Headers.Add('X-Api-Key', $env:DT_API_KEY)
          $resp = $http.SendAsync($msg).GetAwaiter().GetResult()
          if (-not $resp.IsSuccessStatusCode) {
            $text = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
            throw "API $method $path failed ($($resp.StatusCode)): $text"
          }
          return $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
        }

        # ...rest of your script unchanged...
