# Template: upload SBOMs to Dependency-Track with ACID compliance
parameters:
  # Specifies whether the pipeline should fail if any SBOM upload fails
  - name: failOnUploadError
    type: boolean
    default: true
  # Automatically rollback on failure
  - name: enableRollback
    type: boolean
    default: true
  # If true, only performs pre-flight validation without uploading
  - name: validationOnly
    type: boolean
    default: false
  # How long to wait for BOM processing to complete (seconds)
  - name: bomProcessingTimeoutSec
    type: number
    default: 300

steps:
  # Implements two-phase commit: validation phase, then upload phase
  # Tracks uploaded SBOMs for potential rollback on failure
  # Performs pre-flight validation of all SBOMs before starting uploads
  - task: PowerShell@2
    name: uploadScript
    displayName: "Upload SBOMs to Dependency-Track (ACID Compliant)"
    env:
      # Dependency-Track API base URL and key
      DT_API_URL: $(DT_API_URL)
      DT_API_KEY: $(DT_API_KEY)
      # Context and tagging
      CLIENT_NAME: $(CLIENT_NAME)
      ENV_NAME: $(ENV_NAME)
      RELEASE_NUMBER: $(RELEASE_NUMBER)
      ADDITIONAL_TAGS: $(ADDITIONAL_TAGS)
      # Inputs from earlier steps
      SBOM_FILES_JSON: $(discoverSboms.sbomFilesJson)
      PROJECT_TAGS_CSV: $(buildTags.projectTagsCsv)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        
        # ---- Transaction State Management ----
        $uploadedProjects = @()
        $validationResults = @()
        $rollbackRequired = $false
        
        # ---- Guard: ensure API URL/KEY are set ----
        if ([string]::IsNullOrWhiteSpace($env:DT_API_URL) -or [string]::IsNullOrWhiteSpace($env:DT_API_KEY)) {
          throw "DT_API_URL and/or DT_API_KEY not set. Check the 'Dependency-Track' variable group."
        }
        $base = "$($env:DT_API_URL)".TrimEnd('/')
        Write-Host "Using Dependency-Track API base: $base"

        # Retrieve SBOM file paths from the environment variable
        $filesJson = $env:SBOM_FILES_JSON
        if (-not $filesJson -or $filesJson -eq "[]") {
          Write-Host "No SBOM files to upload"
          if ("${{ parameters.failOnUploadError }}" -eq "True") { exit 1 } else { exit 0 }
        }

        $filePaths = $filesJson | ConvertFrom-Json
        $tagsCsv = $env:PROJECT_TAGS_CSV

        # ---- HTTP setup ----
        Add-Type -AssemblyName System.Net.Http
        $http = [System.Net.Http.HttpClient]::new()
        $http.Timeout = [TimeSpan]::FromMinutes(10)
        $http.DefaultRequestHeaders.Add('X-Api-Key', $env:DT_API_KEY)

        # ---- Helper Functions ----
        function Get-AppNameFromSbom([string]$path) {
          try { (Get-Content -Raw -LiteralPath $path | ConvertFrom-Json -ea Stop).metadata.component.name } catch { $null }
        }
        function Get-DeployableFromPath([string]$path) {
          ([IO.Path]::GetFileNameWithoutExtension($path) -replace '-sbom$','') -replace '[^\w\.-]','-'
        }
        function Get-FileSizeKB([string]$path) {
          [math]::Round((Get-Item -LiteralPath $path).Length / 1kb, 0)
        }
        function Invoke-DtApi([string]$method, [string]$path, [object]$body=$null, [int]$retries=3, [string]$baseUrl) {
          $attempt = 0
          $lastErr = $null
          do {
            try {
              $uri  = "$baseUrl$path"
              $msg  = [System.Net.Http.HttpRequestMessage]::new($method, $uri)
              if ($body -ne $null) {
                $json = $body | ConvertTo-Json -Depth 8
                $msg.Content = [System.Net.Http.StringContent]::new($json, [Text.Encoding]::UTF8, 'application/json')
              }
              $msg.Headers.Add('X-Api-Key', $env:DT_API_KEY)
              $resp = $http.SendAsync($msg).GetAwaiter().GetResult()
              $content = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
              if ($resp.IsSuccessStatusCode) { return $content }
              if ([int]$resp.StatusCode -ge 500) { throw "HTTP $($resp.StatusCode): $content" }
              throw "API $method $path failed ($($resp.StatusCode)): $content"
            } catch {
              $lastErr = $_
              $retryable = ($lastErr.Exception -is [System.Net.Http.HttpRequestException]) -or
                           ($lastErr.Exception -is [System.TimeoutException]) -or
                           ($lastErr.Exception -is [System.Net.WebException]) -or
                           ($lastErr.Exception.Message -match '^HTTP 5\d{2}:')
              if (-not $retryable -or $attempt -ge $retries) { throw $lastErr }
              $delay = [int][math]::Pow(2, [double]$attempt)
              Write-Warning "Transient error calling $path. Retry in ${delay}s (attempt $($attempt+1)/$retries): $($lastErr.Exception.Message)"
              Start-Sleep -Seconds $delay
              $attempt++
            }
          } while ($true)
        }
        function Wait-BomProcessed([string]$token, [int]$timeoutSec = 120) {
          if (-not $token) { return $false }
          $deadline = (Get-Date).AddSeconds($timeoutSec)
          while ((Get-Date) -lt $deadline) {
            try {
              $json = Invoke-DtApi -method GET -path "/v1/bom/token/$token" -baseUrl $base
              if ($json) {
                $st = $json | ConvertFrom-Json
                if ($null -ne $st.processing) {
                  Write-Host "BOM token $token status: " + ($(if($st.processing){'PROCESSING'}else{'DONE'}))
                  if (-not $st.processing) { return $true }
                  Start-Sleep -Seconds 2
                  continue
                }
              }
            } catch {
              if ($_.Exception.Message -match '404') {
                Write-Host "BOM token $token status: DONE (token not found)"
                return $true
              }
            }
            Start-Sleep -Seconds 2
          }
          return $false
        }
        function Invoke-RollbackUploads {
          if (-not "${{ parameters.enableRollback }}" -eq "True") {
            Write-Host "Rollback disabled, skipping cleanup"
            return
          }
          $deletedOk = 0; $deactivatedOk = 0; $failed = 0
          Write-Host "##[warning]Starting rollback for $($uploadedProjects.Count) uploaded project(s)..."
          foreach ($project in $uploadedProjects) {
            try {
              $deleteUri = "/v1/project/$($project.Uuid)"
              try {
                [void](Invoke-DtApi -method DELETE -path $deleteUri -baseUrl $base)
                $deletedOk++
                Write-Host "✓ Rolled back via DELETE: $($project.Name) @ $($project.Version)"
              } catch {
                $delErr = $_.Exception.Message
                Write-Warning "DELETE failed for $($project.Name) ($($project.Uuid)): $delErr. Attempting PATCH active=false fallback."
                try {
                  [void](Invoke-DtApi -method PATCH -path "/v1/project/$($project.Uuid)" -body @{ active = $false } -baseUrl $base)
                  $deactivatedOk++
                  Write-Host "✓ Rolled back via PATCH active=false: $($project.Name) @ $($project.Version)"
                } catch {
                  $patchErr = $_.Exception.Message
                  Write-Warning "Fallback PATCH active=false failed for $($project.Name) ($($project.Uuid)): $patchErr"
                  $failed++
                }
              }
            } catch {
              $failed++
              Write-Warning "Unexpected rollback error for $($project.Name) ($($project.Uuid)): $($_.Exception.Message)"
            }
          }
          Write-Host "##[section]Rollback summary → deleted=$deletedOk, deactivated=$deactivatedOk, failed=$failed"
        }
        function Get-ProjectByNameAndVersion([string]$projectName, [string]$projectVersion) {
          try {
            $encodedName = [System.Web.HttpUtility]::UrlEncode($projectName)
            $encodedVersion = [System.Web.HttpUtility]::UrlEncode($projectVersion)
            $searchResult = Invoke-DtApi -method GET -path "/v1/project/lookup?name=$encodedName&version=$encodedVersion" -baseUrl $base
            return $searchResult | ConvertFrom-Json
          } catch {
            return $null
          }
        }

        # ---- PHASE 1: PRE-FLIGHT VALIDATION ----
        Write-Host "##[section]Phase 1: Pre-flight Validation"
        Write-Host "Validating all $($filePaths.Count) SBOM files before upload..."
        function Test-SbomValidation([string]$filePath) {
          Write-Host "Validating SBOM: $filePath"
          $validationResult = @{
            FilePath = $filePath
            IsValid = $true
            Issues = @()
            ProjectName = $null
            ProjectVersion = $null
          }
          try {
            if (-not (Test-Path $filePath)) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "File does not exist"
              return $validationResult
            }
            $fileSize = (Get-Item $filePath).Length
            if ($fileSize -eq 0) { $validationResult.IsValid = $false; $validationResult.Issues += "File is empty"; return $validationResult }
            if ($fileSize -gt 100MB) { $validationResult.IsValid = $false; $validationResult.Issues += "File too large (>100MB)"; return $validationResult }
            try { $sbomContent = Get-Content -Raw -LiteralPath $filePath | ConvertFrom-Json } catch {
              $validationResult.IsValid = $false; $validationResult.Issues += "Invalid JSON format: $($_.Exception.Message)"; return $validationResult
            }
            $f = Get-Item -LiteralPath $filePath
            $appName = Get-AppNameFromSbom $f.FullName
            if (-not $appName) { $appName = $f.Directory.Parent.BaseName }
            if ([string]::IsNullOrWhiteSpace($appName)) {
              $validationResult.IsValid = $false; $validationResult.Issues += "Cannot determine project name"; return $validationResult
            }
            $validationResult.ProjectName = $appName
            $validationResult.ProjectVersion = "release/{0}" -f "$env:RELEASE_NUMBER"
            if (-not $sbomContent.metadata) { $validationResult.IsValid = $false; $validationResult.Issues += "Missing metadata section" }
            Write-Host "✓ SBOM validation passed: $filePath"
          } catch {
            $validationResult.IsValid = $false
            $validationResult.Issues += "Validation error: $($_.Exception.Message)"
          }
          return $validationResult
        }
        $allValid = $true
        foreach ($filePath in $filePaths) {
          $validation = Test-SbomValidation $filePath
          $validationResults += $validation
          if (-not $validation.IsValid) {
            $allValid = $false
            Write-Error "❌ Validation failed for $filePath : $($validation.Issues -join ', ')"
          }
        }
        if (-not $allValid) {
          Write-Host "##[error]Pre-flight validation failed. Aborting upload process."
          Write-Host "##[section]Validation Summary"
          foreach ($result in $validationResults | Where-Object { -not $_.IsValid }) {
            Write-Host "FAILED: $($result.FilePath)"
            foreach ($issue in $result.Issues) { Write-Host "  - $issue" }
          }
          exit 1
        }
        Write-Host "✅ All SBOMs passed pre-flight validation"
        if ("${{ parameters.validationOnly }}" -eq "True") {
          Write-Host "Validation-only mode enabled. Exiting without upload."
          exit 0
        }

        # ---- PHASE 2: ATOMIC UPLOAD PROCESS ----
        Write-Host "##[section]Phase 2: Atomic Upload Process"
        try {
          $uploaded = 0
          $rows = New-Object System.Collections.Generic.List[object]
          foreach ($validation in $validationResults) {
            $filePath = $validation.FilePath
            $f = Get-Item -LiteralPath $filePath
            $projectName = $validation.ProjectName
            $projectVersion = $validation.ProjectVersion
            $parentName = "$projectName.ProjectContainer"
            $parentVersion = ""
            $deployable = Get-DeployableFromPath $f.FullName

            Write-Host "##[group]Uploading SBOM -> $projectName @ $projectVersion"
            try {
              $existingProject = Get-ProjectByNameAndVersion $projectName $projectVersion
              $mp = [System.Net.Http.MultipartFormDataContent]::new()
              $mp.Add([System.Net.Http.StringContent]::new('true'), 'autoCreate')
              $mp.Add([System.Net.Http.StringContent]::new('true'), 'isLatest')
              $mp.Add([System.Net.Http.StringContent]::new($projectName), 'projectName')
              $mp.Add([System.Net.Http.StringContent]::new($projectVersion), 'projectVersion')
              $mp.Add([System.Net.Http.StringContent]::new($parentName), 'parentName')
              $mp.Add([System.Net.Http.StringContent]::new($parentVersion), 'parentVersion')
              if ($tagsCsv -and $tagsCsv.Trim().Length -gt 0) {
                $mp.Add([System.Net.Http.StringContent]::new($tagsCsv), 'projectTags')
              }
              $fs = [System.IO.File]::OpenRead($f.FullName)
              try {
                $fileContent = [System.Net.Http.StreamContent]::new($fs)
                $fileContent.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse('application/json')
                $mp.Add($fileContent, 'bom', $f.Name)
                $resp = $http.PostAsync("$base/v1/bom", $mp).GetAwaiter().GetResult()
              } finally { $fs.Dispose() }
              if (-not $resp.IsSuccessStatusCode) {
                $body = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
                throw "HTTP $($resp.StatusCode) - $body"
              }
              $json = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult() | ConvertFrom-Json
              $note = "token: $($json.token)"
              Write-Host "Uploaded OK: $($f.FullName)  ($note)"

              if (-not $existingProject) {
                $newProject = Get-ProjectByNameAndVersion $projectName $projectVersion
                if ($newProject) {
                  $uploadedProjects += @{
                    Name = $projectName
                    Version = $projectVersion
                    Uuid = $newProject.uuid
                    WasNew = $true
                  }
                }
              }

              $uploaded++
              [void](Wait-BomProcessed -token $json.token -timeoutSec ${{ parameters.bomProcessingTimeoutSec }})

              $rows.Add([pscustomobject]@{
                File     = $f.Name
                SizeKB   = [int]((Get-Item $f.FullName).Length/1kb)
                Project  = $projectName
                Version  = $projectVersion
                Result   = 'OK'
                Note     = $note
              })
            } catch {
              $rollbackRequired = $true
              $errorMsg = $_.Exception.Message
              Write-Error "❌ Upload failed for $($f.FullName): $errorMsg"
              $rows.Add([pscustomobject]@{
                File     = $f.Name
                SizeKB   = [int]((Get-Item $f.FullName).Length/1kb)
                Project  = $projectName
                Version  = $projectVersion
                Result   = 'FAILED'
                Note     = $errorMsg
              })
              throw "Upload failed for $($f.FullName): $errorMsg"
            } finally {
              Write-Host "##[endgroup]"
            }
          }

          # Export compact (Project,Version) JSON for the post-upload verifier
          $rowsJson = ($rows | ForEach-Object { @{ Project = $_.Project; Version = $_.Version } } | ConvertTo-Json -Compress)
          Write-Host "##vso[task.setvariable variable=uploadedRowsJson;isOutput=true]$rowsJson"

          Write-Host "##[section]✅ All uploads completed successfully → ok=$uploaded"
        } catch {
          Write-Host "##[error]Upload process failed: $($_.Exception.Message)"

          if ($rollbackRequired -and $uploadedProjects.Count -gt 0) {
            Invoke-RollbackUploads
          }

          # Export whatever we have so the verifier can still run and report
          $rowsJson = ($rows | ForEach-Object { @{ Project = $_.Project; Version = $_.Version } } | ConvertTo-Json -Compress)
          Write-Host "##vso[task.setvariable variable=uploadedRowsJson;isOutput=true]$rowsJson"

          $md = New-Object System.Collections.Generic.List[string]
          $md.Add("# Dependency-Track Upload Summary (FAILED)")
          $md.Add("")
          $md.Add("**Status:** ❌ Upload failed - Rollback " + $(if("${{ parameters.enableRollback }}" -eq "True"){"executed"}else{"disabled"}))
          $md.Add("")
          $md.Add("| File | Size (KB) | Project | Version | Result | Note |")
          $md.Add("|---|---:|---|---|---|---|")
          foreach ($r in $rows) {
            $md.Add("| $($r.File) | $([int]$r.SizeKB) | $($r.Project) | $($r.Version) | $($r.Result) | $($r.Note -replace '\r?\n',' ') |")
          }
          $summaryPath = Join-Path $env:AGENT_TEMPDIRECTORY "dt-upload-summary.md"
          Set-Content -LiteralPath $summaryPath -Value ($md -join "`r`n") -Encoding UTF8
          Write-Host "##vso[task.uploadsummary]$summaryPath"

          if ("${{ parameters.failOnUploadError }}" -eq "True") { exit 1 }
          return
        }
        
        # ---- SUCCESS: Generate Summary ----
        Write-Host "##[section]Generating Upload Summary"
        $md = New-Object System.Collections.Generic.List[string]
        $md.Add("# Dependency-Track Upload Summary")
        $md.Add("")
        $md.Add("**Status:** ✅ All uploads completed successfully")
        $md.Add("**Total Files:** $($rows.Count)")
        $md.Add("**Rollback Enabled:** " + $(if("${{ parameters.enableRollback }}" -eq "True"){"Yes"}else{"No"}))
        $md.Add("")
        $md.Add("| File | Size (KB) | Project | Version | Result | Note |")
        $md.Add("|---|---:|---|---|---|---|")
        foreach ($r in $rows) {
          $md.Add("| $($r.File) | $([int]$r.SizeKB) | $($r.Project) | $($r.Version) | $($r.Result) | $($r.Note -replace '\r?\n',' ') |")
        }
        $summaryPath = Join-Path $env:AGENT_TEMPDIRECTORY "dt-upload-summary.md"
        Set-Content -LiteralPath $summaryPath -Value ($md -join "`r`n") -Encoding UTF8
        Write-Host "##vso[task.uploadsummary]$summaryPath"

  # Post-upload verification probe
  - template: /src/security/dependency-track/steps/upload/verify-project-state.step.yaml@templates
    parameters:
      enforce: false