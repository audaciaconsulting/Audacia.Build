# Template: upload SBOMs to Dependency-Track with ACID compliance
parameters:
  # Parameter: failOnUploadError
  # - Specifies whether the pipeline should fail if any SBOM upload fails
  # - Default value is true
  - name: failOnUploadError
    type: boolean
    default: true
  # Parameter: enableRollback
  # - Specifies whether to automatically rollback on failure
  # - Default value is true for ACID compliance
  - name: enableRollback
    type: boolean
    default: true
  # Parameter: validationOnly
  # - If true, only performs pre-flight validation without uploading
  # - Useful for testing configuration before actual deployment
  - name: validationOnly
    type: boolean
    default: false

steps:
  # Step: Upload SBOMs to Dependency-Track with ACID compliance
  # - Implements two-phase commit: validation phase, then upload phase
  # - Tracks uploaded SBOMs for potential rollback on failure
  # - Performs pre-flight validation of all SBOMs before starting uploads
  - task: PowerShell@2
    displayName: "Upload SBOMs to Dependency-Track (ACID Compliant)"
    env:
      # Environment variables required for Dependency-Track API
      DT_API_URL: $(DT_API_URL) # Dependency-Track API base URL
      DT_API_KEY: $(DT_API_KEY) # Dependency-Track API key
      CLIENT_NAME: $(CLIENT_NAME) # Client name for tagging
      ENV_NAME: $(ENV_NAME) # Environment name for tagging
      RELEASE_NUMBER: $(RELEASE_NUMBER) # Release number for versioning
      ADDITIONAL_TAGS: $(ADDITIONAL_TAGS) # Additional tags for projects
      SBOM_FILES_JSON: $(discoverSboms.sbomFilesJson) # JSON array of SBOM file paths
      PROJECT_TAGS_CSV: $(buildTags.projectTagsCsv) # CSV of project tags
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        
        # ---- Transaction State Management ----
        # Track uploaded projects for rollback capability
        $uploadedProjects = @()
        $validationResults = @()
        $rollbackRequired = $false
        
        # ---- Guard: ensure API URL/KEY are set ----
        if ([string]::IsNullOrWhiteSpace($env:DT_API_URL) -or [string]::IsNullOrWhiteSpace($env:DT_API_KEY)) {
          throw "DT_API_URL and/or DT_API_KEY not set. Check the 'Dependency-Track' variable group."
        }
        $base = "$($env:DT_API_URL)".TrimEnd('/')
        Write-Host "Using Dependency-Track API base: $base"

        # Retrieve SBOM file paths from the environment variable
        $filesJson = $env:SBOM_FILES_JSON
        if (-not $filesJson -or $filesJson -eq "[]") {
          Write-Host "No SBOM files to upload"
          if ("${{ parameters.failOnUploadError }}" -eq "True") { exit 1 } else { exit 0 }
        }

        $filePaths = $filesJson | ConvertFrom-Json
        $tagsCsv = $env:PROJECT_TAGS_CSV

        # Initialize HTTP client for API requests
        Add-Type -AssemblyName System.Net.Http
        $http = [System.Net.Http.HttpClient]::new()
        $http.Timeout = [TimeSpan]::FromMinutes(10)
        $http.DefaultRequestHeaders.Add('X-Api-Key', $env:DT_API_KEY)

        # ---- Helper Functions ----
        
        function Get-AppNameFromSbom([string]$path) {
          try { (Get-Content -Raw -LiteralPath $path | ConvertFrom-Json -ea Stop).metadata.component.name } catch { $null }
        }

        function Get-DeployableFromPath([string]$path) {
          ([IO.Path]::GetFileNameWithoutExtension($path) -replace '-sbom$','') -replace '[^\w\.-]','-'
        }

        function Get-FileSizeKB([string]$path) {
          [math]::Round((Get-Item -LiteralPath $path).Length / 1kb, 0)
        }

        function Invoke-DtApi([string]$method, [string]$path, [object]$body=$null) {
          $uri  = "$base$path"
          $msg  = New-Object System.Net.Http.HttpRequestMessage($method, $uri)
          if ($body -ne $null) {
            $json = $body | ConvertTo-Json -Depth 8
            $msg.Content = New-Object System.Net.Http.StringContent($json, [Text.Encoding]::UTF8, 'application/json')
          }
          $msg.Headers.Add('X-Api-Key', $env:DT_API_KEY)
          $resp = $http.SendAsync($msg).GetAwaiter().GetResult()
          if (-not $resp.IsSuccessStatusCode) {
            $text = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
            throw "API $method $path failed ($($resp.StatusCode)): $text"
          }
          return $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
        }

        function Wait-BomProcessed([string]$token, [int]$timeoutSec = 120) {
          if (-not $token) { return $false }
          $deadline = (Get-Date).AddSeconds($timeoutSec)
          while ((Get-Date) -lt $deadline) {
            try {
              $json = Invoke-DtApi GET "/v1/bom/token/$token"
              if ($json) {
                $st = $json | ConvertFrom-Json
                if ($null -ne $st.processing) {
                  Write-Host "BOM token $token status: " + ($(if($st.processing){'PROCESSING'}else{'DONE'}))
                  if (-not $st.processing) { return $true }
                  Start-Sleep -Seconds 2
                  continue
                }
              }
            } catch {
              if ($_.Exception.Message -match '404') {
                Write-Host "BOM token $token status: DONE (token not found)"
                return $true
              }
            }
            Start-Sleep -Seconds 2
          }
          return $false
        }

        # ---- New Functions for ACID Compliance ----
        
        function Test-SbomValidation([string]$filePath) {
          Write-Host "Validating SBOM: $filePath"
          $validationResult = @{
            FilePath = $filePath
            IsValid = $true
            Issues = @()
            ProjectName = $null
            ProjectVersion = $null
          }
          
          try {
            # Check if file exists and is readable
            if (-not (Test-Path $filePath)) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "File does not exist"
              return $validationResult
            }
            
            # Check file size (reasonable limits)
            $fileSize = (Get-Item $filePath).Length
            if ($fileSize -eq 0) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "File is empty"
              return $validationResult
            }
            if ($fileSize -gt 100MB) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "File too large (>100MB)"
              return $validationResult
            }
            
            # Validate JSON structure
            try {
              $sbomContent = Get-Content -Raw -LiteralPath $filePath | ConvertFrom-Json
            } catch {
              $validationResult.IsValid = $false
              $validationResult.Issues += "Invalid JSON format: $($_.Exception.Message)"
              return $validationResult
            }
            
            # Extract and validate project information
            $f = Get-Item -LiteralPath $filePath
            $appName = Get-AppNameFromSbom $f.FullName
            if (-not $appName) { $appName = $f.Directory.Parent.BaseName }
            
            if ([string]::IsNullOrWhiteSpace($appName)) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "Cannot determine project name"
              return $validationResult
            }
            
            $validationResult.ProjectName = $appName
            $validationResult.ProjectVersion = "release/{0}" -f "$env:RELEASE_NUMBER"
            
            # Validate required SBOM fields
            if (-not $sbomContent.metadata) {
              $validationResult.IsValid = $false
              $validationResult.Issues += "Missing metadata section"
            }
            
            Write-Host "✓ SBOM validation passed: $filePath"
            
          } catch {
            $validationResult.IsValid = $false
            $validationResult.Issues += "Validation error: $($_.Exception.Message)"
          }
          
          return $validationResult
        }
        
        function Invoke-RollbackUploads {
          if (-not "${{ parameters.enableRollback }}" -eq "True") {
            Write-Host "Rollback disabled, skipping cleanup"
            return
          }
          
          Write-Host "##[warning]Starting rollback process for $($uploadedProjects.Count) uploaded projects..."
          
          foreach ($project in $uploadedProjects) {
            try {
              Write-Host "Rolling back project: $($project.Name) @ $($project.Version)"
              
              # Attempt to delete the project version
              $deleteUri = "/v1/project/$($project.Uuid)"
              try {
                Invoke-DtApi DELETE $deleteUri
                Write-Host "✓ Successfully rolled back: $($project.Name)"
              } catch {
                Write-Warning "Failed to rollback project $($project.Name): $($_.Exception.Message)"
                # Continue with other rollbacks even if one fails
              }
              
            } catch {
              Write-Warning "Error during rollback of $($project.Name): $($_.Exception.Message)"
            }
          }
          
          Write-Host "Rollback process completed"
        }
        
        function Get-ProjectByNameAndVersion([string]$projectName, [string]$projectVersion) {
          try {
            $encodedName = [System.Web.HttpUtility]::UrlEncode($projectName)
            $encodedVersion = [System.Web.HttpUtility]::UrlEncode($projectVersion)
            $searchResult = Invoke-DtApi GET "/v1/project/lookup?name=$encodedName&version=$encodedVersion"
            return $searchResult | ConvertFrom-Json
          } catch {
            return $null
          }
        }

        # ---- PHASE 1: PRE-FLIGHT VALIDATION ----
        Write-Host "##[section]Phase 1: Pre-flight Validation"
        Write-Host "Validating all $($filePaths.Count) SBOM files before upload..."
        
        $allValid = $true
        foreach ($filePath in $filePaths) {
          $validation = Test-SbomValidation $filePath
          $validationResults += $validation
          
          if (-not $validation.IsValid) {
            $allValid = $false
            Write-Error "❌ Validation failed for $filePath : $($validation.Issues -join ', ')"
          }
        }
        
        if (-not $allValid) {
          Write-Host "##[error]Pre-flight validation failed. Aborting upload process."
          Write-Host "##[section]Validation Summary"
          foreach ($result in $validationResults | Where-Object { -not $_.IsValid }) {
            Write-Host "FAILED: $($result.FilePath)"
            foreach ($issue in $result.Issues) {
              Write-Host "  - $issue"
            }
          }
          exit 1
        }
        
        Write-Host "✅ All SBOMs passed pre-flight validation"
        
        # Exit if validation-only mode is enabled
        if ("${{ parameters.validationOnly }}" -eq "True") {
          Write-Host "Validation-only mode enabled. Exiting without upload."
          exit 0
        }
        
        # ---- PHASE 2: ATOMIC UPLOAD PROCESS ----
        Write-Host "##[section]Phase 2: Atomic Upload Process"
        
        try {
          $uploaded = 0
          $rows = New-Object System.Collections.Generic.List[object]
          
          foreach ($validation in $validationResults) {
            $filePath = $validation.FilePath
            $f = Get-Item -LiteralPath $filePath
            $projectName = $validation.ProjectName
            $projectVersion = $validation.ProjectVersion
            $parentName = "$projectName.ProjectContainer"
            $parentVersion = ""
            $deployable = Get-DeployableFromPath $f.FullName

            Write-Host "##[group]Uploading SBOM -> $projectName @ $projectVersion"
            
            try {
              # Check if project already exists
              $existingProject = Get-ProjectByNameAndVersion $projectName $projectVersion
              
              $mp = [System.Net.Http.MultipartFormDataContent]::new()
              $mp.Add([System.Net.Http.StringContent]::new('true'), 'autoCreate')
              $mp.Add([System.Net.Http.StringContent]::new('true'), 'isLatest')
              $mp.Add([System.Net.Http.StringContent]::new($projectName), 'projectName')
              $mp.Add([System.Net.Http.StringContent]::new($projectVersion), 'projectVersion')
              $mp.Add([System.Net.Http.StringContent]::new($parentName), 'parentName')
              $mp.Add([System.Net.Http.StringContent]::new($parentVersion), 'parentVersion')
              if ($tagsCsv -and $tagsCsv.Trim().Length -gt 0) {
                $mp.Add([System.Net.Http.StringContent]::new($tagsCsv), 'projectTags')
              }

              $fs = [System.IO.File]::OpenRead($f.FullName)
              try {
                $fileContent = [System.Net.Http.StreamContent]::new($fs)
                $fileContent.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse('application/json')
                $mp.Add($fileContent, 'bom', $f.Name)
                $resp = $http.PostAsync("$base/v1/bom", $mp).GetAwaiter().GetResult()
              } finally { $fs.Dispose() }

              if (-not $resp.IsSuccessStatusCode) {
                $body = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
                throw "HTTP $($resp.StatusCode) - $body"
              }

              $json = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult() | ConvertFrom-Json
              $note = "token: $($json.token)"
              Write-Host "Uploaded OK: $($f.FullName)  ($note)"
              
              # Track successful upload for potential rollback
              if (-not $existingProject) {
                # Get the created project details for rollback tracking
                $newProject = Get-ProjectByNameAndVersion $projectName $projectVersion
                if ($newProject) {
                  $uploadedProjects += @{
                    Name = $projectName
                    Version = $projectVersion
                    Uuid = $newProject.uuid
                    WasNew = $true
                  }
                }
              }
              
              $uploaded++
              [void](Wait-BomProcessed -token $json.token -timeoutSec 120)
              
              $rows.Add([pscustomobject]@{
                File     = $f.Name
                SizeKB   = [int]((Get-Item $f.FullName).Length/1kb)
                Project  = $projectName
                Version  = $projectVersion
                Result   = 'OK'
                Note     = $note
              })
              
            } catch {
              # CRITICAL: Upload failed - trigger rollback if enabled
              $rollbackRequired = $true
              $errorMsg = $_.Exception.Message
              Write-Error "❌ Upload failed for $($f.FullName): $errorMsg"
              
              $rows.Add([pscustomobject]@{
                File     = $f.Name
                SizeKB   = [int]((Get-Item $f.FullName).Length/1kb)
                Project  = $projectName
                Version  = $projectVersion
                Result   = 'FAILED'
                Note     = $errorMsg
              })
              
              # Immediate failure and rollback for atomicity
              throw "Upload failed for $($f.FullName): $errorMsg"
            } finally {
              Write-Host "##[endgroup]"
            }
          }
          
          Write-Host "##[section]✅ All uploads completed successfully → ok=$uploaded"
          
        } catch {
          Write-Host "##[error]Upload process failed: $($_.Exception.Message)"
          
          if ($rollbackRequired -and $uploadedProjects.Count -gt 0) {
            Invoke-RollbackUploads
          }
          
          # Generate summary even on failure
          $md = New-Object System.Collections.Generic.List[string]
          $md.Add("# Dependency-Track Upload Summary (FAILED)")
          $md.Add("")
          $md.Add("**Status:** ❌ Upload failed - Rollback " + $(if("${{ parameters.enableRollback }}" -eq "True"){"executed"}else{"disabled"}))
          $md.Add("")
          $md.Add("| File | Size (KB) | Project | Version | Result | Note |")
          $md.Add("|---|---:|---|---|---|---|")
          foreach ($r in $rows) {
            $md.Add("| $($r.File) | $([int]$r.SizeKB) | $($r.Project) | $($r.Version) | $($r.Result) | $($r.Note -replace '\r?\n',' ') |")
          }
          $summaryPath = Join-Path $env:AGENT_TEMPDIRECTORY "dt-upload-summary.md"
          Set-Content -LiteralPath $summaryPath -Value ($md -join "`r`n") -Encoding UTF8
          Write-Host "##vso[task.uploadsummary]$summaryPath"
          
          if ("${{ parameters.failOnUploadError }}" -eq "True") { exit 1 }
          return
        }
        
        # ---- SUCCESS: Generate Summary ----
        Write-Host "##[section]Generating Upload Summary"
        $md = New-Object System.Collections.Generic.List[string]
        $md.Add("# Dependency-Track Upload Summary")
        $md.Add("")
        $md.Add("**Status:** ✅ All uploads completed successfully")
        $md.Add("**Total Files:** $($rows.Count)")
        $md.Add("**Rollback Enabled:** " + $(if("${{ parameters.enableRollback }}" -eq "True"){"Yes"}else{"No"}))
        $md.Add("")
        $md.Add("| File | Size (KB) | Project | Version | Result | Note |")
        $md.Add("|---|---:|---|---|---|---|")
        foreach ($r in $rows) {
          $md.Add("| $($r.File) | $([int]$r.SizeKB) | $($r.Project) | $($r.Version) | $($r.Result) | $($r.Note -replace '\r?\n',' ') |")
        }
        $summaryPath = Join-Path $env:AGENT_TEMPDIRECTORY "dt-upload-summary.md"
        Set-Content -LiteralPath $summaryPath -Value ($md -join "`r`n") -Encoding UTF8
        Write-Host "##vso[task.uploadsummary]$summaryPath"

