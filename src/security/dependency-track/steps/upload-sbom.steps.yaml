# Template: download → build tags → preflight discovery/validation → upload with token wait → summary → verify

parameters:
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: failOnUploadError
    type: boolean
    default: true
  - name: requireProjectTags
    type: boolean
    default: true
  - name: validationOnly
    type: boolean
    default: false
  - name: bomProcessingTimeoutSec
    type: number
    default: 300
  - name: parentProjectName
    type: string
    default: ''
  - name: parentProjectVersion
    type: string
    default: ''

steps:
  - task: DownloadPipelineArtifact@2
    displayName: "Download artifact: ${{ parameters.artifactName }}"
    inputs:
      artifact: ${{ parameters.artifactName }}
      buildType: current
      path: "$(Agent.TempDirectory)/sbom"

  - task: PowerShell@2
    displayName: "Build project tags"
    name: buildTags
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $tags = New-Object System.Collections.Generic.List[string]
        if ($env:ENV_NAME -and -not [string]::IsNullOrWhiteSpace($env:ENV_NAME)) { $tags.Add("env:$($env:ENV_NAME)") } else { Write-Warning "ENV_NAME is empty or not set; 'env:<NAME>' tag will be omitted." }
        if ($env:ADDITIONAL_TAGS -and $env:ADDITIONAL_TAGS.Trim().Length -gt 0) {
          $env:ADDITIONAL_TAGS -split ',' | % { $_.Trim() } | ? { $_ } | % { [void]$tags.Add($_) }
        }
        $tagsCsv = ''
        if ($tags.Count -gt 0) {
          $seen=@{}; $deduped = $tags | ? { if ($seen.ContainsKey($_)) {$false} else {$seen[$_]=$true; $true} }
          $tagsCsv = $deduped -join ','
        }
        if ("${{ parameters.requireProjectTags }}" -eq "True" -and [string]::IsNullOrWhiteSpace($tagsCsv)) { throw "No project tags produced." }
        elseif ([string]::IsNullOrWhiteSpace($tagsCsv)) { Write-Warning "No project tags produced (requireProjectTags=false)." }
        Write-Host "Final projectTags CSV: '$tagsCsv'"
        Write-Host "##vso[task.setvariable variable=projectTagsCsv;isOutput=true]$tagsCsv"

  - task: PowerShell@2
    name: preflight
    displayName: "Preflight: discover, validate, and plan uploads"
    env:
      ENV_NAME: $(ENV_NAME)
      RELEASE_NUMBER: $(RELEASE_NUMBER)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        if (-not $env:ENV_NAME -or [string]::IsNullOrWhiteSpace($env:ENV_NAME)) { Write-Warning "ENV_NAME is empty or not set; proceeding without an environment tag." }
        $root = Join-Path $env:AGENT_TEMPDIRECTORY 'sbom'
        if (-not (Test-Path -LiteralPath $root)) { throw "SBOM root not found at $root. Ensure artifact download ran." }
        $files = Get-ChildItem -Path $root -Recurse -File -Filter *.json -EA SilentlyContinue
        if (-not $files -or $files.Count -eq 0) { throw "No SBOM files (*.json) discovered under $root." }

        function Get-AppNameFromSbom([string]$path) { try { (Get-Content -Raw -LiteralPath $path | ConvertFrom-Json -ea Stop).metadata.component.name } catch { $null } }
        function Get-FallbackName([string]$path) { try { $dir = Split-Path $path -Parent; $parent = Split-Path $dir -Leaf; if ([string]::IsNullOrWhiteSpace($parent)) { return (Split-Path $path -Leaf) } return $parent } catch { return (Split-Path $path -Leaf) } }

        $matrix = New-Object System.Collections.Generic.List[object]; $invalid = 0
        foreach ($f in $files) {
          if ($f.Length -eq 0) { Write-Warning "Empty SBOM: $($f.FullName)"; $invalid++; continue }
          try { $json = Get-Content -Raw -LiteralPath $f.FullName | ConvertFrom-Json -ea Stop } catch { Write-Warning "Invalid JSON SBOM: $($f.FullName)"; $invalid++; continue }
          $name = Get-AppNameFromSbom $f.FullName
          if ([string]::IsNullOrWhiteSpace($name)) { $name = Get-FallbackName $f.FullName }
          if ([string]::IsNullOrWhiteSpace($name)) { Write-Warning "Unable to determine project name for SBOM: $($f.FullName)"; $invalid++; continue }
          $version = $env:RELEASE_NUMBER; if ([string]::IsNullOrWhiteSpace($version)) { $version = 'unknown'; Write-Warning "RELEASE_NUMBER is empty; using placeholder 'unknown' for: $name" }
          $matrix.Add([pscustomobject]@{ FilePath=$f.FullName; ProjectName=$name; ProjectVersion=$version })
        }

        if ($matrix.Count -eq 0) { throw "No valid SBOMs after preflight validation; cannot build upload matrix." }
        $out = Join-Path $env:AGENT_TEMPDIRECTORY 'dt-upload-matrix.json'
        ($matrix | ConvertTo-Json -Depth 4 -Compress) | Set-Content -LiteralPath $out -Encoding UTF8
        Write-Host "##[section]Preflight summary → valid=$($matrix.Count), invalid=$invalid"
        Write-Host "Matrix path: $out"
        Write-Host "##vso[task.setvariable variable=UploadMatrixPath;isOutput=true]$out"

  - task: PowerShell@2
    name: uploadScript
    displayName: "Upload SBOMs to Dependency-Track"
    env:
      DT_API_URL: $(DT_API_URL)
      DT_API_KEY: $(DT_API_KEY)
      CLIENT_NAME: $(CLIENT_NAME)
      ENV_NAME: $(ENV_NAME)
      RELEASE_NUMBER: $(RELEASE_NUMBER)
      ADDITIONAL_TAGS: $(ADDITIONAL_TAGS)
      PROJECT_TAGS_CSV: $(buildTags.projectTagsCsv)
      UPLOAD_MATRIX_PATH: $(preflight.UploadMatrixPath)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        if (-not $env:ENV_NAME -or [string]::IsNullOrWhiteSpace($env:ENV_NAME)) { Write-Warning "ENV_NAME is empty or not set; proceeding without an environment tag." }
        if ([string]::IsNullOrWhiteSpace($env:DT_API_URL) -or [string]::IsNullOrWhiteSpace($env:DT_API_KEY)) { throw "DT_API_URL and/or DT_API_KEY not set. Check the variable group." }
        $base = "$($env:DT_API_URL)".TrimEnd('/')
        $matrixPath = $env:UPLOAD_MATRIX_PATH
        if (-not $matrixPath -or -not (Test-Path -LiteralPath $matrixPath)) { throw "Upload matrix file not found: $matrixPath" }
        try { $matrix = Get-Content -Raw -LiteralPath $matrixPath | ConvertFrom-Json } catch { throw "Upload matrix JSON invalid at $matrixPath" }
        if (-not $matrix -or $matrix.Count -eq 0) { throw "Upload matrix is empty; nothing to upload." }

        $parentName    = '${{ parameters.parentProjectName }}'
        $parentVersion = '${{ parameters.parentProjectVersion }}'
        if ($parentName) { Write-Host "Parent project specified → Name='$parentName' Version='$parentVersion'" } else { Write-Host "No parent project specified; uploads will not set parentName/parentVersion." }

        if ("${{ parameters.validationOnly }}" -eq "True") {
          Write-Host "Validation-only mode enabled. Skipping upload."
          Write-Host "##vso[task.setvariable variable=uploadedRowsJson;isOutput=true][]"
          Set-Content -LiteralPath (Join-Path $env:AGENT_TEMPDIRECTORY 'dt-uploaded-rows.json') -Value '[]' -Encoding UTF8
          exit 0
        }

        Add-Type -AssemblyName System.Net.Http
        $http = [System.Net.Http.HttpClient]::new()
        $http.Timeout = [TimeSpan]::FromMinutes(10)
        $http.DefaultRequestHeaders.Add('X-Api-Key', $env:DT_API_KEY)

        function Wait-BomProcessed([string]$token, [int]$timeoutSec = 120) {
          if (-not $token) { return $false }
          $deadline = (Get-Date).AddSeconds($timeoutSec)
          while ((Get-Date) -lt $deadline) {
            try {
              $resp = $http.GetAsync("$base/v1/bom/token/$token").GetAwaiter().GetResult()
              $txt  = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
              if ($resp.IsSuccessStatusCode) {
                $obj = $txt | ConvertFrom-Json
                if ($null -ne $obj.processing) {
                  Write-Host "BOM token $token status: " + ($(if($obj.processing){'PROCESSING'}else{'DONE'}))
                  if (-not $obj.processing) { return $true }
                  Start-Sleep -Seconds 2; continue
                }
              } elseif ([int]$resp.StatusCode -eq 404) {
                Write-Host "BOM token $token status: DONE (token not found)"; return $true
              }
            } catch {}
            Start-Sleep -Seconds 2
          }
          Write-Warning "BOM token $token did not reach DONE within timeout."
          return $false
        }

        $rows = New-Object System.Collections.Generic.List[object]
        try {
          foreach ($item in $matrix) {
            $bom = Get-Item -LiteralPath $item.FilePath
            Write-Host "##[group]Uploading SBOM -> $($item.ProjectName) @ $($item.ProjectVersion)"
            try {
              $form = [System.Net.Http.MultipartFormDataContent]::new()
              $form.Add([System.Net.Http.StringContent]::new('true'), 'autoCreate')
              $form.Add([System.Net.Http.StringContent]::new('true'), 'isLatest')
              $form.Add([System.Net.Http.StringContent]::new($item.ProjectName), 'projectName')
              $form.Add([System.Net.Http.StringContent]::new($item.ProjectVersion), 'projectVersion')
              if ($parentName) {
                $form.Add([System.Net.Http.StringContent]::new($parentName), 'parentName')
                $form.Add([System.Net.Http.StringContent]::new($parentVersion), 'parentVersion')
              }
              if ($env:PROJECT_TAGS_CSV -and $env:PROJECT_TAGS_CSV.Trim().Length -gt 0) {
                $form.Add([System.Net.Http.StringContent]::new($env:PROJECT_TAGS_CSV), 'projectTags')
              }
              $fs = [IO.File]::OpenRead($bom.FullName)
              try {
                $content = [System.Net.Http.StreamContent]::new($fs)
                $content.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse('application/json')
                $form.Add($content, 'bom', $bom.Name)
                $resp = $http.PostAsync("$base/v1/bom", $form).GetAwaiter().GetResult()
              } finally { $fs.Dispose() }

              if (-not $resp.IsSuccessStatusCode) {
                $body = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
                throw "HTTP $($resp.StatusCode) - $body"
              }
              $obj = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult() | ConvertFrom-Json
              $note = "token: $($obj.token)"
              Write-Host "Uploaded OK: $($bom.FullName) ($note)"
              [void](Wait-BomProcessed -token $obj.token -timeoutSec ${{ parameters.bomProcessingTimeoutSec }})
              $rows.Add([pscustomobject]@{ Project=$item.ProjectName; Version=$item.ProjectVersion })
            } catch {
              Write-Error "❌ Upload failed for $($bom.FullName): $($_.Exception.Message)"
              throw
            } finally {
              Write-Host "##[endgroup]"
            }
          }
          $uploaded = ($rows | ConvertTo-Json -Compress); if (-not $uploaded) { $uploaded = '[]' }
          Write-Host "##vso[task.setvariable variable=uploadedRowsJson;isOutput=true]$uploaded"
          Set-Content -LiteralPath (Join-Path $env:AGENT_TEMPDIRECTORY 'dt-uploaded-rows.json') -Value $uploaded -Encoding UTF8
          Write-Host "##[section]✅ All uploads completed successfully"
        } catch {
          $uploaded = ($rows | ConvertTo-Json -Compress); if (-not $uploaded) { $uploaded = '[]' }
          Write-Host "##vso[task.setvariable variable=uploadedRowsJson;isOutput=true]$uploaded"
          Set-Content -LiteralPath (Join-Path $env:AGENT_TEMPDIRECTORY 'dt-uploaded-rows.json') -Value $uploaded -Encoding UTF8
          if ("${{ parameters.failOnUploadError }}" -eq "True") { exit 1 } else { exit 0 }
        }

  - task: PowerShell@2
    displayName: "Upload summary"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        $rowsPath = Join-Path $env:AGENT_TEMPDIRECTORY 'dt-uploaded-rows.json'
        $rows = @()
        if (Test-Path -LiteralPath $rowsPath) {
          try { $rows = Get-Content -Raw -LiteralPath $rowsPath | ConvertFrom-Json } catch { $rows=@() }
        }
        if ($null -eq $rows) { $rows=@() } elseif ($rows -isnot [System.Collections.IEnumerable]) { $rows=@($rows) }
        Write-Host "##[group]Dependency-Track Upload Summary (console)"
        Write-Host ("Total Projects: {0}" -f $rows.Count)
        if ($rows.Count -gt 0) {
          "{0,-50} {1,-30}" -f "Project","Version" | Write-Host
          "{0,-50} {1,-30}" -f "-------","-------" | Write-Host
          foreach ($r in $rows) { "{0,-50} {1,-30}" -f ([string]$r.Project), ([string]$r.Version) | Write-Host }
        } else { Write-Host "_No projects to list._" }
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Verify Dependency-Track project state (post-upload)"
    env:
      DT_API_URL: $(DT_API_URL)
      DT_API_KEY: $(DT_API_KEY)
      UPLOADED_ROWS_JSON: $(uploadScript.uploadedRowsJson)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        if ([string]::IsNullOrWhiteSpace($env:DT_API_URL) -or [string]::IsNullOrWhiteSpace($env:DT_API_KEY)) { throw "DT_API_URL and/or DT_API_KEY not set." }
        $base = "$($env:DT_API_URL)".TrimEnd('/')
        $raw = if ($env:UPLOADED_ROWS_JSON) { $env:UPLOADED_ROWS_JSON } else { '[]' }
        try { $pairs = $raw | ConvertFrom-Json } catch { Write-Error "UPLOADED_ROWS_JSON could not be parsed as JSON."; exit 1 }
        if ($pairs -isnot [System.Collections.IEnumerable]) { $pairs = @($pairs) }
        if (-not $pairs) { $pairs = @() }

        Add-Type -AssemblyName System.Net.Http
        $http=[System.Net.Http.HttpClient]::new(); $http.Timeout=[TimeSpan]::FromMinutes(5); $http.DefaultRequestHeaders.Add('X-Api-Key',$env:DT_API_KEY)

        function Lookup([string]$n,[string]$v) {
          $encN=[uri]::EscapeDataString($n); $encV=[uri]::EscapeDataString($v)
          $resp = $http.GetAsync("$base/v1/project/lookup?name=$encN&version=$encV").GetAwaiter().GetResult()
          $txt = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
          if ($resp.IsSuccessStatusCode) { return $txt | ConvertFrom-Json }
          return $null
        }

        $rows = New-Object System.Collections.Generic.List[object]
        foreach ($p in $pairs) {
          $name=$p.Project; $ver=$p.Version
          if ([string]::IsNullOrWhiteSpace($name) -or [string]::IsNullOrWhiteSpace($ver)) {
            $rows.Add([pscustomobject]@{ Project=$name; Version=$ver; Exists='NO'; IsLatest='N/A'; Note='Missing project or version value' }); continue
          }
          try {
            $obj = Lookup $name $ver
            $exists = ($null -ne $obj -and $obj.uuid)
            $isLatest = $false
            if ($exists -and ($obj.PSObject.Properties.Name -contains 'isLatest')) { $isLatest = [bool]$obj.isLatest }
            $rows.Add([pscustomobject]@{ Project=$name; Version=$ver; Exists=$(if($exists){'YES'}else{'NO'}); IsLatest=$(if($exists){$(if($isLatest){'YES'}else{'NO'})}else{'N/A'}); Note=$(if($exists){"uuid=$($obj.uuid)"}else{"Not found"}) })
          } catch { $rows.Add([pscustomobject]@{ Project=$name; Version=$ver; Exists='UNKNOWN'; IsLatest='UNKNOWN'; Note="Lookup error" }) }
        }

        Write-Host "##[group]Dependency-Track verification details (console)"
        Write-Host ("Checked items: {0}" -f $rows.Count)
        $missing = ($rows | ? { $_.Exists -ne 'YES' }).Count
        $notLatest = ($rows | ? { $_.IsLatest -eq 'NO' }).Count
        Write-Host ("Missing: {0} | Not latest: {1}" -f $missing, $notLatest)
        "{0,-50} {1,-16} {2,-7} {3,-9} {4}" -f "Project","Version","Exists","IsLatest","Note" | Write-Host
        "{0,-50} {1,-16} {2,-7} {3,-9} {4}" -f "-------","-------","------","--------","----" | Write-Host
        foreach ($r in $rows) { "{0,-50} {1,-16} {2,-7} {3,-9} {4}" -f $r.Project, $r.Version, $r.Exists, $r.IsLatest, ($r.Note -replace '\r?\n',' ') | Write-Host }
        Write-Host "##[endgroup]"
