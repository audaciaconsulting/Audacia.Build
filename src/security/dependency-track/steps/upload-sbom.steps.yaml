# Template: download SBOM artifact and upload via Dependency-Track API.
parameters:
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: failOnUploadError
    type: boolean
    default: true

steps:
  - checkout: none

  - task: DownloadPipelineArtifact@2
    displayName: "Download SBOM artifact"
    inputs:
      artifact: ${{ parameters.artifactName }}
      path: $(Agent.TempDirectory)/sbom

  - task: PowerShell@2
    displayName: "Upload SBOMs to Dependency-Track"
    env:
      DT_API_URL: $(DT_API_URL)
      DT_API_KEY: $(DT_API_KEY)
      CLIENT_NAME: $(CLIENT_NAME)
      ENV_NAME: $(ENV_NAME)
      RELEASE_NUMBER: $(RELEASE_NUMBER)
      ADDITIONAL_TAGS: $(ADDITIONAL_TAGS)
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $sbomRoot = "$(Agent.TempDirectory)/sbom"
        if (-not (Test-Path $sbomRoot)) {
          Write-Host "##vso[task.logissue type=warning]No SBOM directory at $sbomRoot"
          if ("${{ parameters.failOnUploadError }}" -eq "true") { exit 1 } else { exit 0 }
        }

        $rows = New-Object System.Collections.Generic.List[object]

        function Get-AppNameFromSbom([string]$path) {
          try { (Get-Content -Raw -LiteralPath $path | ConvertFrom-Json -ea Stop).metadata.component.name } catch { $null }
        }
        function Get-DeployableFromPath([string]$path) {
          ([IO.Path]::GetFileNameWithoutExtension($path) -replace '-sbom$','') -replace '[^\w\.-]','-'
        }
        function Get-FileSizeKB([string]$path) {
          [math]::Round((Get-Item -LiteralPath $path).Length / 1kb, 0)
        }
        function Wait-BomProcessed([string]$token, [int]$timeoutSec = 120) {
          if (-not $token) { return $false }
          $deadline = (Get-Date).AddSeconds($timeoutSec)
          while ((Get-Date) -lt $deadline) {
            try {
              $json = Invoke-DtApi GET "/v1/bom/token/$token"
              if ($json) {
                $st = $json | ConvertFrom-Json
                if ($null -ne $st.processing) {
                  Write-Host "BOM token $token status: " + ($(if($st.processing){'PROCESSING'}else{'DONE'}))
                  if (-not $st.processing) { return $true }
                  Start-Sleep -Seconds 2
                  continue
                }
              }
            } catch {
              if ($_.Exception.Message -match '404') {
                Write-Host "BOM token $token status: DONE (token not found)"
                return $true
              }
            }
            Start-Sleep -Seconds 2
          }
          return $false
        }

        Add-Type -AssemblyName System.Net.Http
        $http = [System.Net.Http.HttpClient]::new()
        $http.Timeout = [TimeSpan]::FromMinutes(10)
        $http.DefaultRequestHeaders.Add('X-Api-Key', "$(DT_API_KEY)")

        function Invoke-DtApi([string]$method, [string]$path, [object]$body=$null) {
          $base = "$(DT_API_URL)".TrimEnd('/')
          $uri  = "$base$path"
          $msg  = New-Object System.Net.Http.HttpRequestMessage($method, $uri)
          if ($body -ne $null) {
            $json = $body | ConvertTo-Json -Depth 8
            $msg.Content = New-Object System.Net.Http.StringContent($json, [Text.Encoding]::UTF8, 'application/json')
          }
          $msg.Headers.Add('X-Api-Key', "$(DT_API_KEY)")
          $resp = $http.SendAsync($msg).GetAwaiter().GetResult()
          if (-not $resp.IsSuccessStatusCode) {
            $text = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
            throw "API $method $path failed ($($resp.StatusCode)): $text"
          }
          return $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
        }

        $files = Get-ChildItem -Path $sbomRoot -Recurse -Filter *.json -File
        if (-not $files) {
          Write-Host "##vso[task.logissue type=warning]No SBOM JSON files found under $sbomRoot"
          if ("${{ parameters.failOnUploadError }}" -eq "true") { exit 1 } else { exit 0 }
        }

        # Build tags (env + optional ADDITIONAL_TAGS)
        $tags = New-Object System.Collections.Generic.List[string]
        $tags.Add("env:$(ENV_NAME)")
        if ($env:ADDITIONAL_TAGS -and $env:ADDITIONAL_TAGS.Trim().Length -gt 0) {
          $extraTags = $env:ADDITIONAL_TAGS -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          foreach ($t in $extraTags) { $tags.Add($t) }
        }
        $tagsCsv = ''
        if ($tags.Count -gt 0) {
          $seen = @{}
          $deduped = $tags | Where-Object { if ($seen.ContainsKey($_)) { $false } else { $seen[$_] = $true; $true } }
          $tagsCsv = $deduped -join ','
        }
        Write-Host "Final projectTags CSV: '$tagsCsv'"

        $uploaded = 0; $failed = 0
        foreach ($f in $files) {
          $appName = Get-AppNameFromSbom $f.FullName
          if (-not $appName) { $appName = $f.Directory.Parent.BaseName }
          $projectName    = $appName
          $parentName     = "$appName.ProjectContainer"
          $parentVersion  = ""
          $projectVersion = "release/{0}" -f "$(RELEASE_NUMBER)"
          $deployable     = Get-DeployableFromPath $f.FullName

          Write-Host "##[group]Uploading SBOM -> $projectName @ $projectVersion"
          $note = ''
          try {
            $mp = [System.Net.Http.MultipartFormDataContent]::new()
            $mp.Add([System.Net.Http.StringContent]::new('true'), 'autoCreate')
            $mp.Add([System.Net.Http.StringContent]::new('true'), 'isLatest')
            $mp.Add([System.Net.Http.StringContent]::new($projectName), 'projectName')
            $mp.Add([System.Net.Http.StringContent]::new($projectVersion), 'projectVersion')
            $mp.Add([System.Net.Http.StringContent]::new($parentName), 'parentName')
            $mp.Add([System.Net.Http.StringContent]::new($parentVersion), 'parentVersion')
            if ($tagsCsv -and $tagsCsv.Trim().Length -gt 0) {
              $mp.Add([System.Net.Http.StringContent]::new($tagsCsv), 'projectTags')
            }

            $fs = [System.IO.File]::OpenRead($f.FullName)
            try {
              $fileContent = [System.Net.Http.StreamContent]::new($fs)
              $fileContent.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse('application/json')
              $mp.Add($fileContent, 'bom', $f.Name)
              $resp = $http.PostAsync("$(DT_API_URL.TrimEnd('/'))/v1/bom", $mp).GetAwaiter().GetResult()
            } finally { $fs.Dispose() }

            if (-not $resp.IsSuccessStatusCode) {
              $body = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult()
              throw "HTTP $($resp.StatusCode) - $body"
            }

            $json = $resp.Content.ReadAsStringAsync().GetAwaiter().GetResult() | ConvertFrom-Json
            $note = "token: $($json.token)"
            Write-Host "Uploaded OK: $($f.FullName)  ($note)"
            $uploaded++

            [void](Wait-BomProcessed -token $json.token -timeoutSec 120)
          } catch {
            $note = $_.Exception.Message
            Write-Warning "Upload failed for $($f.FullName): $note"
            $failed++
          } finally {
            $rows.Add([pscustomobject]@{
              File     = $f.Name
              SizeKB   = [int]((Get-Item $f.FullName).Length/1kb)
              Project  = $projectName
              Version  = $projectVersion
              Result   = $(if ($note -like 'token:*') {'OK'} else {'FAILED'})
              Note     = $note
            })
            Write-Host "##[endgroup]"
          }
        }

        Write-Host "##[section]Dependency-Track upload summary â†’ ok=$uploaded, failed=$failed"

        $md = New-Object System.Collections.Generic.List[string]
        $md.Add("# Dependency-Track Upload Summary")
        $md.Add("")
        $md.Add("| File | Size (KB) | Project | Version | Result | Note |")
        $md.Add("|---|---:|---|---|---|---|")
        foreach ($r in $rows) {
          $md.Add("| $($r.File) | $([int]$r.SizeKB) | $($r.Project) | $($r.Version) | $($r.Result) | $($r.Note -replace '\r?\n',' ') |")
        }
        $summaryPath = Join-Path $env:AGENT_TEMPDIRECTORY "dt-upload-summary.md"
        Set-Content -LiteralPath $summaryPath -Value ($md -join "`r`n") -Encoding UTF8
        Write-Host "##vso[task.uploadsummary]$summaryPath"

        if (("${{ parameters.failOnUploadError }}" -eq "true") -and ($failed -gt 0)) { exit 1 }
