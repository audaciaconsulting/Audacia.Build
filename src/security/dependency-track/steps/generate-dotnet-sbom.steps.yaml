# Template: generate .NET SBOMs using CycloneDX

parameters:
  # One or more .csproj paths. Accepts a single string or a multiline string.
  # Paths may be repo-relative (preferred) or absolute. Mixed separators are normalized.
  - name: dotnetProjects
    type: string
    default: ''

  # Azure Artifacts feed to use for restore when no custom NuGet config is provided.
  # Example formats: "Org/FeedName" or a GUID feed id. Ignored if nugetConfigPath is set.
  - name: vstsFeed
    type: string
    default: ''

  # Optional path to a custom nuget.config. When supplied, this takes precedence over vstsFeed.
  # Use for private feeds, extra sources, or credential flows not covered by NuGetAuthenticate.
  - name: nugetConfigPath
    type: string
    default: ''

  # Publish the SBOM output from this step. Set false when combining with npm to publish once later.
  - name: publishArtifact
    type: boolean
    default: false

  # Logical name for the pipeline artifact when publishing is enabled.
  - name: artifactName
    type: string
    default: 'sbom-files'

  # Build settings used to help CycloneDX resolve evaluated metadata (e.g the Version).
  # The build is guarded so SBOM generation still runs even if the build fails.

  # Whether to build projects before SBOM generation to help CycloneDX resolve evaluated metadata (e.g. Version).
  - name: buildBeforeSbom
    type: boolean
    default: true

  # Configuration to use for the guarded build step (e.g. Release, Debug).
  - name: buildConfiguration
    type: string
    default: 'Release'

  # Continue the build step even if errors occur, so SBOM generation still runs.
  - name: buildContinueOnError
    type: boolean
    default: true

  # Additional arguments to pass to the build command (e.g. custom MSBuild properties).
  - name: buildAdditionalArgs
    type: string
    default: ''

  # When enabled, the script tries PackageVersion, then Version from the .csproj.
  - name: inferVersionFromProject
    type: boolean
    default: true

steps:
  - task: NuGetAuthenticate@1
    displayName: "Authenticate to Azure Artifacts"

  - task: PowerShell@2
    name: normalizeDotnet
    displayName: "Normalize .NET project paths for matcher"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $projectsMultilineLiteral = @'
        ${{ parameters.dotnetProjects }}
        '@
        $inputProjectEntries = @()
        if (-not [string]::IsNullOrWhiteSpace($projectsMultilineLiteral)) {
          # Use simple newline split and trim; discard empty lines (fixes earlier regex capture issue)
          $inputProjectEntries = $projectsMultilineLiteral -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
        }
        $repoRoot = $env:BUILD_SOURCESDIRECTORY
        if (-not $repoRoot) { $repoRoot = $env:SYSTEM_DEFAULTWORKINGDIRECTORY }
        $repoRoot = [IO.Path]::GetFullPath($repoRoot)
        function Convert-ToRelativeIfUnderRoot([string]$fullPath, [string]$rootPath) {
          $resolvedFullPath = [IO.Path]::GetFullPath($fullPath)
          if ($resolvedFullPath.StartsWith($rootPath, [System.StringComparison]::OrdinalIgnoreCase)) {
            return $resolvedFullPath.Substring($rootPath.Length).TrimStart('\\')
          }
          return $resolvedFullPath
        }
        $normalizedProjectPaths = New-Object System.Collections.Generic.List[string]
        foreach ($projectEntry in $inputProjectEntries) {
          if ([string]::IsNullOrWhiteSpace($projectEntry)) { continue }
          $candidatePath = ($projectEntry -replace '/', '\\').Trim().Trim('"').Trim()
          $candidatePath = $candidatePath -replace '\$\((?i:Build\.SourcesDirectory)\)', $repoRoot
          $candidatePath = $candidatePath -replace '\$\((?i:System\.DefaultWorkingDirectory)\)', $repoRoot
          try { $relativeUnderRoot = Convert-ToRelativeIfUnderRoot -fullPath $candidatePath -rootPath $repoRoot } catch { $relativeUnderRoot = $candidatePath }
          $chosenPath = $relativeUnderRoot
          if (-not (Test-Path -LiteralPath (Join-Path $repoRoot $relativeUnderRoot))) {
            if (Test-Path -LiteralPath $candidatePath) {
              $chosenPath = [IO.Path]::GetFullPath($candidatePath)
            } else {
              Write-Warning "Project path could not be verified: '$projectEntry' → '$relativeUnderRoot'. Ensure the file exists."
              $chosenPath = $null
            }
          }
          if (-not [string]::IsNullOrWhiteSpace($chosenPath) -and -not ($normalizedProjectPaths -contains $chosenPath)) {
            $normalizedProjectPaths.Add($chosenPath)
          }
        }
        $normalizedMultiline = ($normalizedProjectPaths -join "`n")
        Write-Host "##[group]Normalized .NET project paths"
        if ($normalizedProjectPaths.Count -gt 0) { $normalizedProjectPaths | ForEach-Object { Write-Host $_ } } else { Write-Host "(none)" }
        Write-Host "##[endgroup]"
        Write-Host "##vso[task.setvariable variable=projectsMultiline;isOutput=true]$normalizedMultiline"
        if ($normalizedProjectPaths.Count -eq 0) {
          Write-Warning "No .NET projects provided after normalization; restore/build will be skipped."
        }

  - task: DotNetCoreCLI@2
    displayName: "Restore .NET projects"
    condition: and(succeeded(), ne(variables['normalizeDotnet.projectsMultiline'], ''))
    inputs:
      command: restore
      projects: "$(normalizeDotnet.projectsMultiline)"
      ${{ if ne(parameters.nugetConfigPath, '') }}:
        nugetConfigPath: ${{ parameters.nugetConfigPath }}
      ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
        vstsFeed: ${{ parameters.vstsFeed }}

  - task: DotNetCoreCLI@2
    displayName: "Build .NET projects (guarded, ${{ parameters.buildConfiguration }})"
    condition: and(succeeded(), eq('${{ parameters.buildBeforeSbom }}','true'), ne(variables['normalizeDotnet.projectsMultiline'], ''))
    continueOnError: ${{ parameters.buildContinueOnError }}
    inputs:
      command: build
      projects: "$(normalizeDotnet.projectsMultiline)"
      arguments: "-c ${{ parameters.buildConfiguration }} ${{ parameters.buildAdditionalArgs }}"
      ${{ if ne(parameters.nugetConfigPath, '') }}:
        nugetConfigPath: ${{ parameters.nugetConfigPath }}
      ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
        vstsFeed: ${{ parameters.vstsFeed }}

  - task: PowerShell@2
    displayName: "Install CycloneDX .NET tool"
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }
        $dotnetToolsPath = "$env:USERPROFILE\.dotnet\tools"
        Write-Host "##vso[task.prependpath]$dotnetToolsPath"
        $env:PATH = "$dotnetToolsPath;$env:PATH"
        dotnet CycloneDX --version | Write-Host
        Write-Host "Installed tools in: $dotnetToolsPath"
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Generate .NET SBOMs (CycloneDX, JSON)"
    name: genDotnet
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'
        New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/sbom/dotnet" -Force | Out-Null
        $sbomOutputDirectory = "$(Agent.TempDirectory)/sbom/dotnet"
        $normalizedProjectsRaw = '$(normalizeDotnet.projectsMultiline)'
        $normalizedProjects = @()
        if (-not [string]::IsNullOrWhiteSpace($normalizedProjectsRaw)) {
          # Correct splitting: simple newline, trim, discard empties
          $normalizedProjects = $normalizedProjectsRaw -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
        }
        Write-Host "Projects to process: $($normalizedProjects.Count)"
        if (-not $normalizedProjects -or $normalizedProjects.Count -eq 0) {
          Write-Host "##[section].NET summary → ok=0, failed=0"
          Write-Warning "No .NET projects provided; skipping .NET generation."
          exit 0
        }
        function Get-XmlValueFirstNonEmpty { param([xml]$xml, [string[]]$xpathCandidates) foreach ($xpath in $xpathCandidates) { try { $node = $xml.SelectSingleNode($xpath); if ($node -and -not [string]::IsNullOrWhiteSpace($node.InnerText)) { return $node.InnerText.Trim() } } catch {} } return $null }
        function Get-ProjectVersionFromCsproj { param([string]$csprojPath) try { [xml]$xml = Get-Content -Raw -LiteralPath $csprojPath; Get-XmlValueFirstNonEmpty -xml $xml -xpathCandidates @('/Project/PropertyGroup/PackageVersion','/Project/PropertyGroup/Version') } catch { $null } }
        function Get-AssemblyVersionFromBin { param([string]$csprojPath) try { $projectDir = Split-Path -Parent $csprojPath; $projectBaseName = [IO.Path]::GetFileNameWithoutExtension($csprojPath); $binDir = Join-Path $projectDir 'bin'; if (-not (Test-Path -LiteralPath $binDir)) { return $null }; $candidateDlls = Get-ChildItem -Path $binDir -Recurse -Filter "$projectBaseName*.dll" -File -EA SilentlyContinue | Sort-Object LastWriteTimeUtc -Descending; $newestDll = $candidateDlls | Select-Object -First 1; if (-not $newestDll) { return $null }; $fvi = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($newestDll.FullName); if ($fvi -and $fvi.ProductVersion -and $fvi.ProductVersion.Trim()) { return $fvi.ProductVersion.Trim() }; if ($fvi -and $fvi.FileVersion -and $fvi.FileVersion.Trim()) { return $fvi.FileVersion.Trim() }; return $null } catch { $null } }
        function Resolve-VersionForProject { param([string]$csprojPath) if ('${{ parameters.inferVersionFromProject }}' -ne 'True') { return $null }; $v = Get-ProjectVersionFromCsproj -csprojPath $csprojPath; if (-not [string]::IsNullOrWhiteSpace($v)) { return $v }; Get-AssemblyVersionFromBin -csprojPath $csprojPath }
        $successCount = 0; $failureCount = 0
        foreach ($projectPath in $normalizedProjects) {
          $fullProjectPath = $projectPath; if (-not [System.IO.Path]::IsPathRooted($fullProjectPath)) { $fullProjectPath = Join-Path $env:BUILD_SOURCESDIRECTORY $projectPath }
          $projectBaseName = [IO.Path]::GetFileNameWithoutExtension($fullProjectPath); $outputFileName = "$projectBaseName-sbom.json"
          Write-Host "##[group].NET → $fullProjectPath"
          try {
            $resolvedVersion = Resolve-VersionForProject -csprojPath $fullProjectPath
            if ($resolvedVersion) { Write-Host "Resolved version for SBOM metadata: $resolvedVersion" } else { Write-Host "No version resolved; CycloneDX will fall back to defaults." }
            $args = @("$fullProjectPath","-o","$sbomOutputDirectory","-F","Json","-fn","$outputFileName"); if ($resolvedVersion) { $args += @("--set-version", $resolvedVersion) }
            dotnet CycloneDX @args; if ($LASTEXITCODE -ne 0) { throw "CycloneDX exit code: $LASTEXITCODE" }
            if (Test-Path (Join-Path $sbomOutputDirectory $outputFileName)) { $successCount++ } else { $failureCount++ }
          } catch { Write-Warning "CycloneDX .NET failed: $($_.Exception.Message)"; $failureCount++ } finally { Write-Host "Output: $(Join-Path $sbomOutputDirectory $outputFileName)"; Write-Host "##[endgroup]" }
        }
        Write-Host "##[section].NET summary → ok=$successCount, failed=$failureCount"
        if ($failureCount -gt 0) { Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed"; exit 1 }

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: "Publish SBOM artifact"
        inputs:
          targetPath: "$(Agent.TempDirectory)/sbom"
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
