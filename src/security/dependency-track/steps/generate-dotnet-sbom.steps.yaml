## Template: generate .NET SBOMs using CycloneDX (Simplified)

parameters:
  # One or more .csproj paths. Accepts a single string or a multiline string.
  # Paths may be repo-relative (preferred) or absolute. Mixed separators are normalized.
  - name: dotnetProjects
    type: string
    default: ''

  # Azure Artifacts feed to use for restore when no custom NuGet config is provided.
  # Example formats: "Org/FeedName" or a GUID feed id. Ignored if nugetConfigPath is set.
  - name: vstsFeed
    type: string
    default: ''

  # Optional path to a custom nuget.config. When supplied, this takes precedence over vstsFeed.
  # Use for private feeds, extra sources, or credential flows not covered by NuGetAuthenticate.
  - name: nugetConfigPath
    type: string
    default: ''

  # Publish the SBOM output from this step. Set false when combining with npm to publish once later.
  - name: publishArtifact
    type: boolean
    default: false

  # Logical name for the pipeline artifact when publishing is enabled.
  - name: artifactName
    type: string
    default: 'sbom-files'

  # Determines whether the pipeline is generating SBOMs for a .NET Framework project.
  - name: isDotnetFramework
    type: boolean
    default: false

  - name: buildWholeSolution
    type: boolean
    default: false

  # Set true for legacy ASP.NET Web Application projects that require Microsoft.WebApplication.targets
  - name: useVSToolsPath
    type: boolean
    default: false

  # Build settings used to help CycloneDX resolve evaluated metadata (e.g the Version).
  # The build is guarded so SBOM generation still runs even if the build fails.

  # Whether to build projects before SBOM generation to help CycloneDX resolve evaluated metadata (e.g. Version).
  - name: buildBeforeSbom
    type: boolean
    default: true

  # Configuration to use for the guarded build step (e.g. Release, Debug).
  - name: buildConfiguration
    type: string
    default: 'Release'

  # Continue the build step even if errors occur, so SBOM generation still runs.
  - name: buildContinueOnError
    type: boolean
    default: true

  # Additional arguments to pass to the build command (e.g. custom MSBuild properties).
  - name: buildAdditionalArgs
    type: string
    default: ''

  # When enabled, the script tries PackageVersion, then Version from the .csproj.
  - name: inferVersionFromProject
    type: boolean
    default: true

steps:
  - task: NuGetAuthenticate@1
    displayName: 'Authenticate (Azure Artifacts)'

  # 1. Parse the multiline project list and validate.
  - task: PowerShell@2
    name: normalize
    displayName: 'Validate & capture .csproj list'
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $raw = @'
        ${{ parameters.dotnetProjects }}
        '@
        $lines = $raw -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        if ($lines.Count -eq 0) { throw "No .csproj paths supplied (dotnetProjects parameter)." }

        $root = $env:BUILD_SOURCESDIRECTORY
        if (-not $root) { $root = $env:SYSTEM_DEFAULTWORKINGDIRECTORY }
        $root = [IO.Path]::GetFullPath($root)

        $validated = New-Object System.Collections.Generic.List[string]
        foreach ($p in $lines) {
          $candidate = $p
          if (-not [IO.Path]::IsPathRooted($candidate)) { $candidate = Join-Path $root $candidate }
          if (-not (Test-Path -LiteralPath $candidate)) { throw "Path not found: $p (resolved '$candidate')" }
          if ([IO.Path]::GetExtension($candidate) -ne '.csproj') { throw "Not a .csproj file: $candidate" }
          if (-not ($validated -contains $candidate)) { $validated.Add($candidate) }
        }

        $multiline = ($validated -join "%0A")
        $validated | ForEach-Object { Write-Host $_ }
        Write-Host "##vso[task.setvariable variable=projectsMultiline;isOutput=true]$multiline"
        
        # Also emit a JSON array to avoid multi-line truncation issues across tasks
        $json = ($validated | ConvertTo-Json -Compress -AsArray)
        Write-Host "##vso[task.setvariable variable=projectsJson;isOutput=true]$json"

  - ${{ if eq(parameters.isDotnetFramework, false) }}:
    # 2. Restore (single task using DotNetCoreCLI for simplicity & feed wiring).
    - task: DotNetCoreCLI@2
      displayName: 'Restore projects'
      condition: and(succeeded(), or(ne(variables['normalize.projectsJson'], ''), ne(variables['normalize.projectsMultiline'], '')))
      inputs:
        command: restore
        projects: '$(normalize.projectsMultiline)'
        ${{ if ne(parameters.nugetConfigPath, '') }}:
          feedsToUse: 'config'
          nugetConfigPath: ${{ parameters.nugetConfigPath }}
        ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
          vstsFeed: ${{ parameters.vstsFeed }}

    # 3. Optional guarded build (improves version resolution).
    - task: DotNetCoreCLI@2
      # Guarded/non-blocking: continueOnError allows SBOM generation to proceed even if compilation fails.
      displayName: 'Build projects (non-blocking / guarded)'
      condition: and(succeeded(), eq('${{ parameters.buildBeforeSbom }}','true'), or(ne(variables['normalize.projectsJson'], ''), ne(variables['normalize.projectsMultiline'], '')))
      continueOnError: ${{ parameters.buildContinueOnError }}
      inputs:
        command: build
        projects: '$(normalize.projectsMultiline)'
        arguments: '-c ${{ parameters.buildConfiguration }} ${{ parameters.buildAdditionalArgs }}'
        ${{ if ne(parameters.nugetConfigPath, '') }}:
          feedsToUse: 'config'
          nugetConfigPath: ${{ parameters.nugetConfigPath }}
        ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
          vstsFeed: ${{ parameters.vstsFeed }}

  - ${{ else }}:
    # 2. Nuget Restore
    - task: NuGetToolInstaller@1
      displayName: 'Use NuGet'

    - task: NuGetCommand@2
      name: NuGetCommand1
      displayName: NuGet restore
      inputs:
        restoreSolution: '**/*.sln'
        ${{ if ne(parameters.nugetConfigPath, '') }}:
          selectOrConfig: config
          nugetConfigPath: ${{ parameters.nugetConfigPath }}
        ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
          vstsFeed: ${{ parameters.vstsFeed }}

    - ${{ if eq(parameters.buildWholeSolution, 'true') }}:
      # 3. Build Solution
      - task: MSBuild@1
        displayName: 'Build solution'
        inputs:
          solution: '**/*.sln'
          msbuildArchitecture: x64
          configuration: ${{ parameters.buildConfiguration }}
          platform: 'Any CPU'
          msbuildArguments: '/t:Rebuild ${{ parameters.buildAdditionalArgs }}'

    - ${{ else }}:
      # 3. Build Projects
      - task: PowerShell@2
        displayName: 'Build all projects'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            $ErrorActionPreference = 'Stop'
          
            # Locate MSBuild via vswhere
            $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            $msbuildPath = & $vswhere -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe | Select-Object -First 1
            
            $buildArgs = @(
              '/t:Rebuild',
              '/p:Configuration=${{ parameters.buildConfiguration }}',
              '/p:OutDir=$(Build.ArtifactStagingDirectory)\',
              '/p:Platform=AnyCPU'
              ${{ parameters.buildAdditionalArgs }}
            )
          
            Write-Host "Build args: $buildArgs"
          
            $projects = '$(normalize.projectsJson)' | ConvertFrom-Json

            foreach ($project in $projects) {
              Write-Host "Building: $project"
            
              & $msbuildPath $project $buildArgs

              if ($LASTEXITCODE -ne 0) { throw "Build failed for: $project" }
            }


  # 4. Ensure CycloneDX tool available.
  - task: PowerShell@2
    displayName: 'Install CycloneDX tool'
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "CycloneDX tool install failed." }
        }
        $toolsPath = "$env:USERPROFILE\.dotnet\tools"
        Write-Host "##vso[task.prependpath]$toolsPath"
        $env:PATH = "$toolsPath;$env:PATH"
        dotnet CycloneDX --version | Write-Host

  # 5. Generate SBOMs.
  - task: PowerShell@2
    name: generate
    displayName: 'Generate SBOMs (CycloneDX JSON)'
    condition: and(succeeded(), or(ne(variables['normalize.projectsJson'], ''), ne(variables['normalize.projectsMultiline'], '')))
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference='Stop'
        $projects = @()
        $projectsJsonRaw = '$(normalize.projectsJson)'
        if ($projectsJsonRaw -and $projectsJsonRaw.Trim().Length -gt 0) {
          try { $projects = @($projectsJsonRaw | ConvertFrom-Json) } catch { $projects = @() }
        }
        if (-not $projects -or $projects.Count -eq 0) {
          $projectsRaw = '$(normalize.projectsMultiline)'
          $projects = $projectsRaw -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        }
        if ($projects.Count -eq 0) { throw "No projects resolved for generation." }
        Write-Host ("Projects to generate SBOMs for: {0}" -f $projects.Count)
        foreach ($p in $projects) { Write-Host (" - {0}" -f $p) }

        $outputRoot = "$(Agent.TempDirectory)/sbom/dotnet"
        New-Item -ItemType Directory -Path $outputRoot -Force | Out-Null

        function Get-ProjectVersionOrNull([string]$path) {
          if ('${{ parameters.inferVersionFromProject }}' -ne 'True') { return $null }
          try {
            [xml]$xml = Get-Content -Raw -LiteralPath $path
            $val = $xml.SelectSingleNode('/Project/PropertyGroup/PackageVersion')
            if ($val -and $val.InnerText.Trim()) { return $val.InnerText.Trim() }
            $val = $xml.SelectSingleNode('/Project/PropertyGroup/Version')
            if ($val -and $val.InnerText.Trim()) { return $val.InnerText.Trim() }
          } catch {}
          return $null
        }

        $ok = 0; $failed = 0
        foreach ($proj in $projects) {
          $base = [IO.Path]::GetFileNameWithoutExtension($proj)
          $outFile = "$base-sbom.json"
          $version = Get-ProjectVersionOrNull $proj
          Write-Host ("Generating SBOM for: {0}" -f $proj)
          if ($version) { Write-Host "Version inferred: $version" }
          $args = @($proj,'-o',$outputRoot,'-F','Json','-fn',$outFile)
          if ($version) { $args += @('--set-version',$version) }
          dotnet CycloneDX @args
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "CycloneDX failed (exit $LASTEXITCODE)"
            $failed++
          } else {
            if (Test-Path (Join-Path $outputRoot $outFile)) { $ok++ } else { $failed++; Write-Warning "Missing expected output: $outFile" }
          }
          Write-Host "Output: $(Join-Path $outputRoot $outFile)"
        }

        Write-Host "##[section].NET summary â†’ ok=$ok, failed=$failed"
        if ($failed -gt 0) { Write-Host "##vso[task.logissue type=warning]Some SBOM generation failures"; exit 1 }

  # 6. Optional artifact publish (combined folder root kept consistent).
  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: 'Publish SBOM artifact'
        inputs:
          targetPath: '$(Agent.TempDirectory)/sbom'
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
