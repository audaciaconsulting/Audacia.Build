# Template: generate .NET SBOMs using CycloneDX

parameters:
  # One or more .csproj paths. Accepts a single string or a multiline string.
  # Paths may be repo-relative (preferred) or absolute. Mixed separators are normalized.
  - name: dotnetProjects
    type: string
    default: ''

  # Azure Artifacts feed to use for restore when no custom NuGet config is provided.
  # Example formats: "Org/FeedName" or a GUID feed id. Ignored if nugetConfigPath is set.
  - name: vstsFeed
    type: string
    default: ''

  # Optional path to a custom nuget.config. When supplied, this takes precedence over vstsFeed.
  # Use for private feeds, extra sources, or credential flows not covered by NuGetAuthenticate.
  - name: nugetConfigPath
    type: string
    default: ''

  # Publish the SBOM output from this step. Set false when combining with npm to publish once later.
  - name: publishArtifact
    type: boolean
    default: false

  # Logical name for the pipeline artifact when publishing is enabled.
  - name: artifactName
    type: string
    default: 'sbom-files'

  # Build settings used to help CycloneDX resolve evaluated metadata (e.g the Version).
  # The build is guarded so SBOM generation still runs even if the build fails.

  # Whether to build projects before SBOM generation to help CycloneDX resolve evaluated metadata (e.g. Version).
  - name: buildBeforeSbom
    type: boolean
    default: true

  # Configuration to use for the guarded build step (e.g. Release, Debug).
  - name: buildConfiguration
    type: string
    default: 'Release'

  # Continue the build step even if errors occur, so SBOM generation still runs.
  - name: buildContinueOnError
    type: boolean
    default: true

  # Additional arguments to pass to the build command (e.g. custom MSBuild properties).
  - name: buildAdditionalArgs
    type: string
    default: ''

  # When enabled, the script tries PackageVersion, then Version from the .csproj.
  - name: inferVersionFromProject
    type: boolean
    default: true

steps:
  - task: NuGetAuthenticate@1
    displayName: "Authenticate to Azure Artifacts"

  - task: PowerShell@2
    name: normalizeDotnet
    displayName: "Normalize .NET project paths for matcher"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $projectsMultilineLiteral = @'
        ${{ parameters.dotnetProjects }}
        '@
        $inputProjectEntries = @()
        if (-not [string]::IsNullOrWhiteSpace($projectsMultilineLiteral)) {
          # Simple newline split + trim; discard empties (fixes previous regex capture issue)
          $inputProjectEntries = $projectsMultilineLiteral -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
        }
        $repoRoot = $env:BUILD_SOURCESDIRECTORY
        if (-not $repoRoot) { $repoRoot = $env:SYSTEM_DEFAULTWORKINGDIRECTORY }
        $repoRoot = [IO.Path]::GetFullPath($repoRoot)
        function Convert-ToRelativeIfUnderRoot([string]$fullPath, [string]$rootPath) {
          $resolvedFullPath = [IO.Path]::GetFullPath($fullPath)
          if ($resolvedFullPath.StartsWith($rootPath, [System.StringComparison]::OrdinalIgnoreCase)) {
            $relative = $resolvedFullPath.Substring($rootPath.Length).TrimStart('\\')
            return $relative
          }
          return $resolvedFullPath
        }
        $normalizedProjectPaths = New-Object System.Collections.Generic.List[string]
        foreach ($projectEntry in $inputProjectEntries) {
          if (-not [string]::IsNullOrWhiteSpace($projectEntry)) {
            $candidatePath = ($projectEntry -replace '/', '\\').Trim().Trim('"').Trim()
            $candidatePath = $candidatePath -replace '\$\((?i:Build\.SourcesDirectory)\)', $repoRoot
            $candidatePath = $candidatePath -replace '\$\((?i:System\.DefaultWorkingDirectory)\)', $repoRoot
            try { $relativeUnderRoot = Convert-ToRelativeIfUnderRoot -fullPath $candidatePath -rootPath $repoRoot } catch { $relativeUnderRoot = $candidatePath }
            $chosenPath = $relativeUnderRoot
            if (-not (Test-Path -LiteralPath (Join-Path $repoRoot $relativeUnderRoot))) {
              if (Test-Path -LiteralPath $candidatePath) {
                $chosenPath = [IO.Path]::GetFullPath($candidatePath)
              } else {
                Write-Warning "Project path could not be verified: '$projectEntry' → '$relativeUnderRoot'. Ensure the file exists."
                $chosenPath = $null
              }
            }
            if (-not [string]::IsNullOrWhiteSpace($chosenPath) -and -not ($normalizedProjectPaths -contains $chosenPath)) {
              $normalizedProjectPaths.Add($chosenPath)
            }
          }
        }
        $normalizedMultiline = ($normalizedProjectPaths -join "`n")
        $normalizedJson = ($normalizedProjectPaths | ConvertTo-Json -Compress -AsArray)
        Write-Host "##[group]Normalized .NET project paths"
        if ($normalizedProjectPaths.Count -gt 0) { $normalizedProjectPaths | ForEach-Object { Write-Host $_ } } else { Write-Host "(none)" }
        Write-Host "##[endgroup]"
        Write-Host "##vso[task.setvariable variable=projectsMultiline;isOutput=true]$normalizedMultiline"
        Write-Host "##vso[task.setvariable variable=projectsJson;isOutput=true]$normalizedJson"
        if ($normalizedProjectPaths.Count -eq 0) {
          Write-Error "No .NET project paths resolved after normalization. Verify inputs."
        }

  - task: PowerShell@2
    displayName: "Restore .NET projects (per-project)"
    condition: and(succeeded(), ne(variables['normalizeDotnet.projectsJson'], ''))
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $projectsJson = '$(normalizeDotnet.projectsJson)'
        $projects = @()
        try { $projects = @($projectsJson | ConvertFrom-Json) } catch { $projects = @() }
        if ($projects.Count -eq 0) { throw "No projects to restore." }
        Write-Host "##[group]Restore .NET projects"
        foreach ($p in $projects) {
          $fullPath = $p
          if (-not [System.IO.Path]::IsPathRooted($fullPath)) { $fullPath = Join-Path $env:BUILD_SOURCESDIRECTORY $p }
          Write-Host "Restoring: $fullPath"
          dotnet restore "$fullPath"
          if ($LASTEXITCODE -ne 0) { throw "dotnet restore failed for $fullPath (exit $LASTEXITCODE)" }
        }
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Build .NET projects (guarded per-project, ${{ parameters.buildConfiguration }})"
    condition: and(succeeded(), eq('${{ parameters.buildBeforeSbom }}','true'), ne(variables['normalizeDotnet.projectsJson'], ''))
    continueOnError: ${{ parameters.buildContinueOnError }}
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        $projectsJson = '$(normalizeDotnet.projectsJson)'
        $projects = @()
        try { $projects = @($projectsJson | ConvertFrom-Json) } catch { $projects = @() }
        if ($projects.Count -eq 0) { Write-Host "No projects to build"; exit 0 }
        Write-Host "##[group]Build .NET projects (${{ parameters.buildConfiguration }})"
        foreach ($p in $projects) {
          $fullPath = $p
          if (-not [System.IO.Path]::IsPathRooted($fullPath)) { $fullPath = Join-Path $env:BUILD_SOURCESDIRECTORY $p }
          Write-Host "Building: $fullPath"
          dotnet build "$fullPath" -c "${{ parameters.buildConfiguration }}" ${{ parameters.buildAdditionalArgs }}
          # Errors are tolerated per task's continueOnError
        }
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Install CycloneDX .NET tool"
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }
        $dotnetToolsPath = "$env:USERPROFILE\.dotnet\tools"
        Write-Host "##vso[task.prependpath]$dotnetToolsPath"
        $env:PATH = "$dotnetToolsPath;$env:PATH"
        dotnet CycloneDX --version | Write-Host
        Write-Host "Installed tools in: $dotnetToolsPath"
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Generate .NET SBOMs (CycloneDX, JSON)"
    name: genDotnet
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'

        # ----------------------------------------
        # Directories / Initialisation
        # ----------------------------------------
        $sbomOutputRoot = "$(Agent.TempDirectory)/sbom/dotnet"
        New-Item -ItemType Directory -Path $sbomOutputRoot -Force | Out-Null
        $sbomOutputDirectory = $sbomOutputRoot

        # ----------------------------------------
        # Resolve project list (prefer JSON variable; fallback to multiline)
        # ----------------------------------------
        $normalizedProjects = @()
        $projectsJsonVar = '$(normalizeDotnet.projectsJson)'
        if ($projectsJsonVar -and $projectsJsonVar.Trim().Length -gt 0) {
          try { $normalizedProjects = @($projectsJsonVar | ConvertFrom-Json) } catch { $normalizedProjects = @() }
        }
        if (-not $normalizedProjects -or $normalizedProjects.Count -eq 0) {
          $normalizedProjectsRaw = '$(normalizeDotnet.projectsMultiline)'
          if ($normalizedProjectsRaw) {
            $normalizedProjects = $normalizedProjectsRaw -split "`n" |
              ForEach-Object { $_.Trim() } |
              Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
          }
        }

        Write-Host "Projects to process: $($normalizedProjects.Count)"
        if (-not $normalizedProjects -or $normalizedProjects.Count -eq 0) {
          Write-Host "##[section].NET summary → ok=0, failed=0"
          Write-Warning "No .NET projects provided; skipping .NET generation."
          exit 0
        }

        # ----------------------------------------
        # Helper functions
        # ----------------------------------------
        function Get-XmlValueFirstNonEmpty {
          param(
            [xml]$xml,
            [string[]]$xpathCandidates
          )
          foreach ($xpath in $xpathCandidates) {
            try {
              $node = $xml.SelectSingleNode($xpath)
              if ($node -and -not [string]::IsNullOrWhiteSpace($node.InnerText)) {
                return $node.InnerText.Trim()
              }
            } catch {}
          }
          return $null
        }

        function Get-ProjectVersionFromCsproj {
          param(
            [string]$csprojPath
          )
          try {
            [xml]$xml = Get-Content -Raw -LiteralPath $csprojPath
            return Get-XmlValueFirstNonEmpty -xml $xml -xpathCandidates @(
              '/Project/PropertyGroup/PackageVersion',
              '/Project/PropertyGroup/Version'
            )
          } catch { return $null }
        }

        function Get-AssemblyVersionFromBin {
          param(
            [string]$csprojPath
          )
          try {
            $projectDir      = Split-Path -Parent $csprojPath
            $projectBaseName = [IO.Path]::GetFileNameWithoutExtension($csprojPath)
            $binDir          = Join-Path $projectDir 'bin'
            if (-not (Test-Path -LiteralPath $binDir)) { return $null }
            $candidateDlls = Get-ChildItem -Path $binDir -Recurse -Filter "$projectBaseName*.dll" -File -EA SilentlyContinue |
              Sort-Object LastWriteTimeUtc -Descending
            $newestDll = $candidateDlls | Select-Object -First 1
            if (-not $newestDll) { return $null }
            $fileVersionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($newestDll.FullName)
            if ($fileVersionInfo -and $fileVersionInfo.ProductVersion -and $fileVersionInfo.ProductVersion.Trim()) { return $fileVersionInfo.ProductVersion.Trim() }
            if ($fileVersionInfo -and $fileVersionInfo.FileVersion -and $fileVersionInfo.FileVersion.Trim())     { return $fileVersionInfo.FileVersion.Trim() }
            return $null
          } catch { return $null }
        }

        function Resolve-VersionForProject {
          param(
            [string]$csprojPath
          )
          if ('${{ parameters.inferVersionFromProject }}' -ne 'True') { return $null }
          $resolvedProjectVersion = Get-ProjectVersionFromCsproj -csprojPath $csprojPath
          if (-not [string]::IsNullOrWhiteSpace($resolvedProjectVersion)) { return $resolvedProjectVersion }
          return Get-AssemblyVersionFromBin -csprojPath $csprojPath
        }

        # ----------------------------------------
        # Generate SBOMs per project
        # ----------------------------------------
        $successCount = 0
        $failureCount = 0

        foreach ($projectPath in $normalizedProjects) {
          $fullProjectPath = $projectPath
          if (-not [System.IO.Path]::IsPathRooted($fullProjectPath)) {
            $fullProjectPath = Join-Path $env:BUILD_SOURCESDIRECTORY $projectPath
          }

            $projectBaseName  = [IO.Path]::GetFileNameWithoutExtension($fullProjectPath)
            $outputFileName   = "$projectBaseName-sbom.json"
            $outputFileFull   = Join-Path $sbomOutputDirectory $outputFileName

          Write-Host "##[group].NET → $fullProjectPath"
          try {
            $resolvedVersion = Resolve-VersionForProject -csprojPath $fullProjectPath
            if ($resolvedVersion) {
              Write-Host "Resolved version for SBOM metadata: $resolvedVersion"
            } else {
              Write-Host "No version resolved; CycloneDX will use defaults."
            }

            $args = @(
              "$fullProjectPath",
              '-o', $sbomOutputDirectory,
              '-F', 'Json',
              '-fn', $outputFileName
            )
            if ($resolvedVersion) { $args += @('--set-version', $resolvedVersion) }

            dotnet CycloneDX @args
            if ($LASTEXITCODE -ne 0) { throw "CycloneDX exit code: $LASTEXITCODE" }

            if (Test-Path $outputFileFull) {
              $successCount++
            } else {
              $failureCount++
              Write-Warning "Expected output file not found: $outputFileFull"
            }
          } catch {
            Write-Warning "CycloneDX .NET failed for '$fullProjectPath': $($_.Exception.Message)"
            $failureCount++
          } finally {
            Write-Host "Output: $outputFileFull"
            Write-Host "##[endgroup]"
          }
        }

        # ----------------------------------------
        # Summary / Result
        # ----------------------------------------
        Write-Host "##[section].NET summary → ok=$successCount, failed=$failureCount"
        if ($failureCount -gt 0) {
          Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed"
          exit 1
        }

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: "Publish SBOM artifact"
        inputs:
          targetPath: "$(Agent.TempDirectory)/sbom"
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
