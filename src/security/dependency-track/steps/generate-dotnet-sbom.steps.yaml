# Template: generate .NET SBOMs using CycloneDX

parameters:
  # One or more .csproj paths. Accepts a single string or a multiline string.
  # Paths may be repo-relative (preferred) or absolute. Mixed separators are normalized.
  - name: dotnetProjects
    type: string
    default: ''

  # Azure Artifacts feed to use for restore when no custom NuGet config is provided.
  # Example formats: "Org/FeedName" or a GUID feed id. Ignored if nugetConfigPath is set.
  - name: vstsFeed
    type: string
    default: ''

  # Optional path to a custom nuget.config. When supplied, this takes precedence over vstsFeed.
  # Use for private feeds, extra sources, or credential flows not covered by NuGetAuthenticate.
  - name: nugetConfigPath
    type: string
    default: ''

  # Publish the SBOM output from this step. Set false when combining with npm to publish once later.
  - name: publishArtifact
    type: boolean
    default: false

  # Logical name for the pipeline artifact when publishing is enabled.
  - name: artifactName
    type: string
    default: 'sbom-files'

  # Build settings used to help CycloneDX resolve the evaluated version and metadata.
  # The build is guarded so SBOM generation still runs even if the build fails.
  - name: buildBeforeSbom
    type: boolean
    default: true
  - name: buildConfiguration
    type: string
    default: 'Release'
  - name: buildContinueOnError
    type: boolean
    default: true
  - name: buildAdditionalArgs
    type: string
    default: ''

steps:
  - task: NuGetAuthenticate@1
    displayName: "Authenticate to Azure Artifacts"

  - task: PowerShell@2
    name: normalizeDotnet
    displayName: "Normalize .NET project paths for matcher"
    inputs:
      pwsh: true
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'

        $projectsMultilineLiteral = @'
        ${{ parameters.dotnetProjects }}
        '@

        $inputProjectEntries = @()
        if (-not [string]::IsNullOrWhiteSpace($projectsMultilineLiteral)) {
          $inputProjectEntries = $projectsMultilineLiteral -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
        }

        $repoRoot = $env:BUILD_SOURCESDIRECTORY
        if (-not $repoRoot) { $repoRoot = $env:SYSTEM_DEFAULTWORKINGDIRECTORY }
        $repoRoot = [IO.Path]::GetFullPath($repoRoot)

        function Convert-ToRelativeIfUnderRoot([string]$fullPath, [string]$rootPath) {
          $resolvedFullPath = [IO.Path]::GetFullPath($fullPath)
          if ($resolvedFullPath.StartsWith($rootPath, [System.StringComparison]::OrdinalIgnoreCase)) {
            $relative = $resolvedFullPath.Substring($rootPath.Length).TrimStart('\')
            return $relative
          }
          return $resolvedFullPath
        }

        $normalizedProjectPaths = New-Object System.Collections.Generic.List[string]
        
        foreach ($projectEntry in $inputProjectEntries) {
          if (-not [string]::IsNullOrWhiteSpace($projectEntry)) {
            $candidatePath = ($projectEntry -replace '/', '\').Trim().Trim('"').Trim()

            $candidatePath = $candidatePath -replace '\$\((?i:Build\.SourcesDirectory)\)', $repoRoot
            $candidatePath = $candidatePath -replace '\$\((?i:System\.DefaultWorkingDirectory)\)', $repoRoot

            try { $relativeUnderRoot = Convert-ToRelativeIfUnderRoot -fullPath $candidatePath -rootPath $repoRoot } catch { $relativeUnderRoot = $candidatePath }

            $chosenPath = $relativeUnderRoot

            if (-not (Test-Path -LiteralPath (Join-Path $repoRoot $relativeUnderRoot))) {
              if (Test-Path -LiteralPath $candidatePath) {
                $chosenPath = [IO.Path]::GetFullPath($candidatePath)
              } else {
                Write-Warning "Project path could not be verified: '$projectEntry' → '$relativeUnderRoot'. Ensure the file exists."
              }
            }
        
            # Dedupe only truly identical project files to avoid generating the same SBOM twice.
            # This does not hide real duplicate applications or identical Dependency-Track project names.
            if (-not [string]::IsNullOrWhiteSpace($chosenPath) -and -not ($normalizedProjectPaths -contains $chosenPath)) {
              $normalizedProjectPaths.Add($chosenPath)
            }
          }
        }

        if ($normalizedProjectPaths.Count -eq 0) {
          Write-Host "##[section].NET summary → ok=0, failed=0"
          Write-Warning "No .NET projects provided after normalization; DotNet restore will be skipped."
        }

        $normalizedMultiline = ($normalizedProjectPaths -join "`n")
        Write-Host "##[group]Normalized .NET project paths"
        $normalizedProjectPaths | ForEach-Object { Write-Host $_ }
        Write-Host "##[endgroup]"
        Write-Host "##vso[task.setvariable variable=projectsMultiline;isOutput=true]$normalizedMultiline"

  - task: DotNetCoreCLI@2
    displayName: "Restore .NET projects"
    condition: and(succeeded(), ne(variables['normalizeDotnet.projectsMultiline'], ''))
    inputs:
      command: restore
      projects: "$(normalizeDotnet.projectsMultiline)"
      ${{ if ne(parameters.nugetConfigPath, '') }}:
        nugetConfigPath: ${{ parameters.nugetConfigPath }}
      ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
        vstsFeed: ${{ parameters.vstsFeed }}

  # Guarded build to help CycloneDX resolve evaluated version and other metadata
  - task: DotNetCoreCLI@2
    displayName: "Build .NET projects (guarded, ${{ parameters.buildConfiguration }})"
    condition: and(succeeded(), eq('${{ parameters.buildBeforeSbom }}','true'), ne(variables['normalizeDotnet.projectsMultiline'], ''))
    continueOnError: ${{ parameters.buildContinueOnError }}
    inputs:
      command: build
      projects: "$(normalizeDotnet.projectsMultiline)"
      arguments: "-c ${{ parameters.buildConfiguration }} ${{ parameters.buildAdditionalArgs }}"
      ${{ if ne(parameters.nugetConfigPath, '') }}:
        nugetConfigPath: ${{ parameters.nugetConfigPath }}
      ${{ if and(eq(parameters.nugetConfigPath, ''), ne(parameters.vstsFeed, '')) }}:
        vstsFeed: ${{ parameters.vstsFeed }}

  - task: PowerShell@2
    displayName: "Install CycloneDX .NET tool"
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }
        $dotnetToolsPath = "$env:USERPROFILE\.dotnet\tools"
        Write-Host "##vso[task.prependpath]$dotnetToolsPath"
        $env:PATH = "$dotnetToolsPath;$env:PATH"
        dotnet CycloneDX --version | Write-Host
        Write-Host "Installed tools in: $dotnetToolsPath"
        Write-Host "##[endgroup]"

  - task: PowerShell@2
    displayName: "Generate .NET SBOMs (CycloneDX, JSON)"
    name: genDotnet
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $ErrorActionPreference = 'Stop'
        New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/sbom/dotnet" -Force | Out-Null
        $sbomOutputDirectory = "$(Agent.TempDirectory)/sbom/dotnet"

        $normalizedProjectsRaw = '$(normalizeDotnet.projectsMultiline)'
        $normalizedProjects = @()
        if ($normalizedProjectsRaw) { $normalizedProjects = $normalizedProjectsRaw -split "(\r?\n)" | Where-Object { $_ -and $_ -notmatch "^\r?$" } }

        if (-not $normalizedProjects -or $normalizedProjects.Count -eq 0) {
          Write-Host "##[section].NET summary → ok=0, failed=0"
          Write-Warning "No .NET projects provided; skipping .NET generation."
          exit 0
        }

        $successCount = 0
        $failureCount = 0
        foreach ($projectPath in $normalizedProjects) {
          $fullProjectPath = $projectPath
          if (-not [System.IO.Path]::IsPathRooted($fullProjectPath)) {
            $fullProjectPath = Join-Path $env:BUILD_SOURCESDIRECTORY $projectPath
          }
          $projectBaseName = [IO.Path]::GetFileNameWithoutExtension($fullProjectPath)
          $outputFileName = "$projectBaseName-sbom.json"
          Write-Host "##[group].NET → $fullProjectPath"
          try {
            dotnet CycloneDX "$fullProjectPath" -o "$sbomOutputDirectory" -F Json -fn "$outputFileName"
            if ($LASTEXITCODE -ne 0) { throw "CycloneDX exit code: $LASTEXITCODE" }
            if (Test-Path (Join-Path $sbomOutputDirectory $outputFileName)) { $successCount++ } else { $failureCount++ }
          } catch {
            Write-Warning "CycloneDX .NET failed: $($_.Exception.Message)"; $failureCount++
          } finally {
            Write-Host "Output: $(Join-Path $sbomOutputDirectory $outputFileName)"
            Write-Host "##[endgroup]"
          }
        }

        Write-Host "##[section].NET summary → ok=$successCount, failed=$failureCount"
        if ($failureCount -gt 0) { Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed"; exit 1 }

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: "Publish SBOM artifact"
        inputs:
          targetPath: "$(Agent.TempDirectory)/sbom"
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
