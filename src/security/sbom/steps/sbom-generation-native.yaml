parameters:
  - name: sbomOutputDir
    type: string
    default: '$(Agent.TempDirectory)/sbom'
  - name: outputFormat
    type: string
    default: 'cyclonedx-json'     # Ignored internally; we always emit JSON.
  - name: publishArtifact
    type: boolean
    default: true
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: nodeVersion
    type: string
    default: '20.x'
  - name: includeLicenseTexts
    type: boolean
    default: true
  - name: npmRootsMultiline
    type: string
    default: ''                    # Optional: one root per line; otherwise auto-discover (npm only)
  - name: dotnetProjectsMultiline
    type: string
    default: ''                    # One .sln/.csproj path per line

steps:
  - powershell: |
      Write-Host "##[group]Environment & Parameters"
      Write-Host "Agent.OS: $env:AGENT_OS"
      Write-Host "Output format: JSON (forced)"
      Write-Host "Include license texts: ${{ parameters.includeLicenseTexts }}"
      Write-Host "SBOM output dir: ${{ parameters.sbomOutputDir }}"
      Write-Host "Sources: $(Build.SourcesDirectory)"
      Write-Host "##[endgroup]"
    displayName: Log parameters

  - task: UseNode@1
    displayName: Use Node.js ${{ parameters.nodeVersion }}
    inputs:
      versionSpec: ${{ parameters.nodeVersion }}
      checkLatest: true

  - task: PowerShell@2
    displayName: Install CycloneDX .NET tool
    inputs:
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          Write-Host "cyclonedx-dotnet not found; installing..."
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }
        $dotnetTools = "$env:USERPROFILE\.dotnet\tools"
        # make it available now and for later tasks
        $env:PATH = "$dotnetTools;$env:PATH"
        Write-Host "##vso[task.prependpath]$dotnetTools"
        # verify via 'dotnet CycloneDX' (works even if shim name differs)
        dotnet CycloneDX --version
        if ($LASTEXITCODE -ne 0) { throw "CycloneDX CLI not found after install." }
        Write-Host "Installed tools in: $dotnetTools"
        Write-Host "##[endgroup]"

  - powershell: |
      New-Item -ItemType Directory -Path "${{ parameters.sbomOutputDir }}" -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "npm") -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "dotnet") -Force | Out-Null
    displayName: Prepare output folders

  # npm SBOMs with cyclonedx-npm (JSON)
  - powershell: |
      $ErrorActionPreference = 'Stop'
      Write-Host "##[group]Discover JS package managers"
      $repoRoot = "$(Build.SourcesDirectory)"
      $locks_npm  = Get-ChildItem -Path $repoRoot -Recurse -Filter 'package-lock.json' -File
      Write-Host "Found npm package-lock.json: $($locks_npm.Count)"
      if ($locks_pnpm.Count -gt 0) {
        Write-Host "##vso[task.logissue type=warning]Detected pnpm-lock.yaml ($($locks_pnpm.Count)). @cyclonedx/cyclonedx-npm does not support PNPM; use @cyclonedx/cyclonedx-pnpm instead."
      }
      Write-Host "##[endgroup]"

      Write-Host "##[group]Resolve roots"
      $rootsParam = @()
      $raw = @'
      ${{ parameters.npmRootsMultiline }}
      '@
      $rootsParam = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' -and -not $_.StartsWith('#') }
      $projects = New-Object System.Collections.ArrayList

      if ($rootsParam.Count -gt 0) {
        foreach ($r in $rootsParam) {
          if (Test-Path (Join-Path $r 'package-lock.json')) {
            [void]$projects.Add($r)
            Write-Host "Root (param): $r"
          } else {
            Write-Warning "No package-lock.json under: $r (skipped)"
          }
        }
      } else {
        foreach ($l in $locks_npm)  { [void]$projects.Add($l.Directory.FullName) }
        $projects = $projects | Select-Object -Unique
        foreach ($p in $projects) { Write-Host "Root (auto): $p" }
      }
      Write-Host "##[endgroup]"

      $count = ($projects | Measure-Object).Count
      if ($count -eq 0) {
        Write-Host "##vso[task.logissue type=warning]No npm projects discovered. Ensure lockfiles are committed or pass npmRootsMultiline."
        Write-Host "##[section]npm summary → ok=0, failed=0"
        return
      }

      $npmOk = 0; $npmFail = 0
      $format = 'json'; $fileExt = 'json'

      foreach ($proj in $projects) {
        $name = Split-Path $proj -Leaf
        if ([string]::IsNullOrWhiteSpace($name)) { $name = 'app' }
        $safe = ($name -replace '[<>:"/\\|?*]', '-').Trim().TrimEnd('.',' ')
        $outDir = Join-Path "${{ parameters.sbomOutputDir }}" ("npm\" + $safe)
        New-Item -ItemType Directory -Path $outDir -Force | Out-Null
        $outFile = Join-Path $outDir ("$safe-sbom.$fileExt")

        Write-Host "##[group]JS SBOM → $proj"
        Push-Location $proj
        try {
          $args = @('--output-format', $format, '--output-file', $outFile)
          if ('${{ parameters.includeLicenseTexts }}' -eq 'True') { $args += @('--gather-license-texts') }
          # cyclonedx-npm auto-detects npm via lockfile presence
          npx -y '@cyclonedx/cyclonedx-npm' @args
          if (Test-Path $outFile) { $npmOk++ } else { $npmFail++ }
        } catch {
          Write-Warning "cyclonedx-npm failed: $($_.Exception.Message)"
          $npmFail++
        } finally {
          Pop-Location | Out-Null
          Write-Host "Output: $outFile"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section]npm summary → ok=$npmOk, failed=$npmFail"
      if ($npmFail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some JS SBOMs failed" }
    displayName: Generate JS SBOMs (npm, JSON)

  - powershell: |
      Write-Host "##[group].NET projects"
      $raw = @'
      ${{ parameters.dotnetProjectsMultiline }}
      '@
      $projPaths = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' -and -not $_.StartsWith('#') }
      $projPaths | ForEach-Object { Write-Host "Path: $_" }
      Write-Host "##[endgroup]"

      if ($projPaths.Count -eq 0) {
        Write-Host "##vso[task.logissue type=warning].NET project list empty; skipping"
        return
      }

      $outDir = Join-Path "${{ parameters.sbomOutputDir }}" "dotnet"
      $format = 'Json'; $ext = 'json'
      $ok = 0; $fail = 0

      foreach ($p in $projPaths) {
        $base = [System.IO.Path]::GetFileNameWithoutExtension($p)
        $fileName = "{0}-sbom.{1}" -f $base, $ext

        Write-Host "##[group].NET → $p"
        try {
          dotnet restore "$p" | Out-Null
          dotnet CycloneDX "$p" -o "$outDir" -F "$format" -fn "$fileName"
          if ($LASTEXITCODE -ne 0) { throw "CycloneDX exit code: $LASTEXITCODE" }
          if (Test-Path (Join-Path $outDir $fileName)) { $ok++ } else { $fail++ }
        } catch {
          Write-Warning "CycloneDX .NET failed: $($_.Exception.Message)"
          $fail++
        } finally {
          Write-Host "Output: $(Join-Path $outDir $fileName)"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section].NET summary → ok=$ok, failed=$fail"
      if ($fail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed" }
    displayName: Generate .NET SBOMs (CycloneDX, JSON)

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: Publish SBOM artifact
        inputs:
          targetPath: ${{ parameters.sbomOutputDir }}
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
