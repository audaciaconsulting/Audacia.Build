parameters:
  - name: sbomOutputDir
    type: string
    default: '$(Agent.TempDirectory)/sbom'
  - name: outputFormat
    type: string
    default: 'cyclonedx-json'     # Ignored internally; this template emits JSON.
  - name: publishArtifact
    type: boolean
    default: true
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: nodeVersion
    type: string
    default: '20.x'
  - name: includeLicenseTexts
    type: boolean
    default: true
  - name: npmRootsMultiline
    type: string
    default: ''                    # Optional: one root per line; otherwise auto-discover
  - name: dotnetProjectsMultiline
    type: string
    default: ''                    # One .sln/.csproj path per line

steps:
  - powershell: |
      Write-Host "##[group]Environment & Parameters"
      Write-Host "Agent.OS: $env:AGENT_OS"
      Write-Host "Output format: JSON (forced)"
      Write-Host "Include license texts: ${{ parameters.includeLicenseTexts }}"
      Write-Host "SBOM output dir: ${{ parameters.sbomOutputDir }}"
      Write-Host "Sources: $(System.DefaultWorkingDirectory)"
      Write-Host "##[endgroup]"
    displayName: Log parameters

  - task: UseNode@1
    displayName: Use Node.js ${{ parameters.nodeVersion }}
    inputs:
      versionSpec: ${{ parameters.nodeVersion }}
      checkLatest: true

  - powershell: |
      # Find the Node tool selected by UseNode@1 in the hosted tool cache and
      # compute the matching npm.cmd and npx.cmd so we never hit the old Node 10 shims.
      $ErrorActionPreference = 'Stop'

      function Get-NodeToolPaths {
        param([string]$major = '20')
        $root = Join-Path $env:AGENT_TOOLSDIRECTORY 'node'
        if (-not (Test-Path $root)) { throw "Node tools directory not found: $root" }
        $ver = Get-ChildItem $root -Directory -Name | Where-Object { $_ -like "$major.*" } | Sort-Object { [version]$_ } -Descending | Select-Object -First 1
        if (-not $ver) { throw "No Node $major.* found under $root" }
        $bin = Join-Path (Join-Path $root $ver) 'x64'
        $node = Join-Path $bin 'node.exe'
        $npm  = Join-Path $bin 'npm.cmd'
        $npx  = Join-Path $bin 'npx.cmd'
        if (-not (Test-Path $node)) { throw "node.exe not found at $node" }
        if (-not (Test-Path $npm))  { throw "npm.cmd not found at $npm" }
        if (-not (Test-Path $npx))  { throw "npx.cmd not found at $npx" }
        [pscustomobject]@{ Node=$node; Npm=$npm; Npx=$npx; Bin=$bin; Version=$ver }
      }

      $tool = Get-NodeToolPaths -major '20'

      Write-Host "##[group]Node tooling (resolved)"
      & $tool.Node --version
      & $tool.Npm  --version
      & $tool.Npx  --version
      Write-Host "Resolved bin: $($tool.Bin)"
      Write-Host "##[endgroup]"

      # Persist for subsequent steps in this job (not strictly required since we call absolute paths)
      Write-Host "##vso[task.setvariable variable=SBOM_NODE_BIN]$($tool.Bin)"
      Write-Host "##vso[task.setvariable variable=SBOM_NODE]$($tool.Node)"
      Write-Host "##vso[task.setvariable variable=SBOM_NPM]$($tool.Npm)"
      Write-Host "##vso[task.setvariable variable=SBOM_NPX]$($tool.Npx)"
    displayName: Debug - resolve Node 20 toolchain paths

  - task: PowerShell@2
    displayName: Install CycloneDX .NET tool
    inputs:
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          Write-Host "cyclonedx-dotnet not found; installing..."
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }
        $dotnetTools = "$env:USERPROFILE\.dotnet\tools"
        $env:PATH = "$dotnetTools;$env:PATH"
        Write-Host "##vso[task.prependpath]$dotnetTools"
        dotnet CycloneDX --version
        if ($LASTEXITCODE -ne 0) { throw "CycloneDX CLI not found after install." }
        Write-Host "Installed tools in: $dotnetTools"
        Write-Host "##[endgroup]"

  - powershell: |
      New-Item -ItemType Directory -Path "${{ parameters.sbomOutputDir }}" -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "npm") -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "dotnet") -Force | Out-Null
    displayName: Prepare output folders

  # npm SBOMs with cyclonedx-npm (JSON) — autodetect package-lock.json; fallback to package.json + create lockfile
  - powershell: |
      $ErrorActionPreference = 'Stop'

      # Use the Node 20 toolchain we resolved earlier
      $npx = "$(SBOM_NPX)"
      $npm = "$(SBOM_NPM)"
      if (-not (Test-Path $npx) -or -not (Test-Path $npm)) {
        throw "Resolved npm/npx not found. Did the previous step set SBOM_NPX/SBOM_NPM?"
      }

      Write-Host "##[group]Discover JS manifests"
      $repoRoot = "$(System.DefaultWorkingDirectory)"
      $locks_npm = Get-ChildItem -Path $repoRoot -Recurse -Filter 'package-lock.json' -File -ErrorAction SilentlyContinue
      $pkgs      = Get-ChildItem -Path $repoRoot -Recurse -Filter 'package.json'      -File -ErrorAction SilentlyContinue
      Write-Host "Found package-lock.json: $($locks_npm.Count)"
      Write-Host "Found package.json:      $($pkgs.Count)"
      Write-Host "##[endgroup]"

      Write-Host "##[group]Resolve roots"
      $raw = @'
      ${{ parameters.npmRootsMultiline }}
      '@
      $rootsParam = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -and -not $_.StartsWith('#') }
      $projects = New-Object System.Collections.ArrayList

      if ($rootsParam.Count -gt 0) {
        foreach ($r in $rootsParam) {
          if (Test-Path (Join-Path $r 'package.json')) {
            [void]$projects.Add($r)
            Write-Host "Root (param): $r"
          } else {
            Write-Warning "package.json not found under: $r (skipped)"
          }
        }
      } else {
        if ($locks_npm.Count -gt 0) {
          foreach ($l in $locks_npm) { [void]$projects.Add($l.Directory.FullName) }
        } elseif ($pkgs.Count -gt 0) {
          foreach ($p in $pkgs) { [void]$projects.Add($p.Directory.FullName) }
        }
        $projects = $projects | Select-Object -Unique
        foreach ($p in $projects) { Write-Host "Root (auto): $p" }
      }
      Write-Host "##[endgroup]"

      $count = ($projects | Measure-Object).Count
      if ($count -eq 0) {
        Write-Host "##[section]npm summary → ok=0, failed=0"
        Write-Host "##vso[task.logissue type=warning]No npm projects discovered. Set npmRootsMultiline or commit lockfiles."
        exit 0
      }

      $npmOk = 0; $npmFail = 0
      $format = 'json'; $fileExt = 'json'

      foreach ($proj in $projects) {
        $name = Split-Path $proj -Leaf
        if ([string]::IsNullOrWhiteSpace($name)) { $name = 'app' }
        $safe = ($name -replace '[<>:"/\\|?*]', '-').Trim().TrimEnd('.',' ')
        $outDir = Join-Path "${{ parameters.sbomOutputDir }}" ("npm\" + $safe)
        New-Item -ItemType Directory -Path $outDir -Force | Out-Null
        $outFile = Join-Path $outDir ("$safe-sbom.$fileExt")

        Write-Host "##[group]JS SBOM → $proj"
        Push-Location $proj
        try {
          $hasLock = Test-Path -LiteralPath (Join-Path $proj 'package-lock.json')
          if (-not $hasLock -and (Test-Path -LiteralPath (Join-Path $proj 'package.json'))) {
            # Create a lockfile quickly without installing packages (using Node 20 npm)
            Write-Host "No package-lock.json; creating one with 'npm install --package-lock-only'"
            & $npm install --package-lock-only --ignore-scripts --no-audit --no-fund
            $hasLock = Test-Path -LiteralPath (Join-Path $proj 'package-lock.json')
            if (-not $hasLock) { throw "Failed to create package-lock.json" }
          }
          $args = @('--output-format', $format, '--output-file', $outFile)
          if ('${{ parameters.includeLicenseTexts }}' -eq 'True') { $args += @('--gather-license-texts') }
          # Use the Node 20 npx directly; also pin to latest CLI
          & $npx --yes @cyclonedx/cyclonedx-npm@latest @args
          if (Test-Path $outFile) { $npmOk++ } else { $npmFail++ }
        } catch {
          Write-Warning "cyclonedx-npm failed: $($_.Exception.Message)"
          $npmFail++
        } finally {
          Pop-Location | Out-Null
          Write-Host "Output: $outFile"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section]npm summary → ok=$npmOk, failed=$npmFail"
      if ($npmFail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some JS SBOMs failed" }
      if ($npmFail -gt 0) { exit 1 }
    displayName: Generate JS SBOMs (npm, JSON)

  - powershell: |
      Write-Host "##[group].NET projects"
      $raw = @'
      ${{ parameters.dotnetProjectsMultiline }}
      '@
      $projPaths = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' -and -not $_.StartsWith('#') }
      $projPaths | ForEach-Object { Write-Host "Path: $_" }
      Write-Host "##[endgroup]"

      if ($projPaths.Count -eq 0) {
        Write-Host "##vso[task.logissue type=warning].NET project list empty; skipping"
        exit 0
      }

      $outDir = Join-Path "${{ parameters.sbomOutputDir }}" "dotnet"
      $format = 'Json'; $ext = 'json'
      $ok = 0; $fail = 0

      foreach ($p in $projPaths) {
        $base = [System.IO.Path]::GetFileNameWithoutExtension($p)
        $fileName = "{0}-sbom.{1}" -f $base, $ext

        Write-Host "##[group].NET → $p"
        try {
          # Uses credentials established by NuGetAuthenticate + pre-warmed assets from DotNetCoreCLI@2 restore
          dotnet restore "$p" | Out-Null
          dotnet CycloneDX "$p" -o "$outDir" -F "$format" -fn "$fileName"
          if ($LASTEXITCODE -ne 0) { throw "CycloneDX exit code: $LASTEXITCODE" }
          if (Test-Path (Join-Path $outDir $fileName)) { $ok++ } else { $fail++ }
        } catch {
          Write-Warning "CycloneDX .NET failed: $($_.Exception.Message)"
          $fail++
        } finally {
          Write-Host "Output: $(Join-Path $outDir $fileName)"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section].NET summary → ok=$ok, failed=$fail"
      if ($fail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed" }
      if ($fail -gt 0) { exit 1 }
    displayName: Generate .NET SBOMs (CycloneDX, JSON)

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: Publish SBOM artifact
        inputs:
          targetPath: ${{ parameters.sbomOutputDir }}
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
