parameters:
  - name: sbomOutputDir
    type: string
    default: '$(Agent.TempDirectory)/sbom'
  - name: outputFormat
    type: string
    default: 'cyclonedx-json'     # cyclonedx-json | cyclonedx-xml
  - name: publishArtifact
    type: boolean
    default: true
  - name: artifactName
    type: string
    default: 'sbom-files'
  - name: nodeVersion
    type: string
    default: '20.x'
  - name: includeLicenseTexts
    type: boolean
    default: true
  - name: npmRootsMultiline
    type: string
    default: ''                    # Optional: one root per line; otherwise we auto-discover via package-lock.json
  - name: dotnetProjectsMultiline
    type: string
    default: ''                    # One .sln/.csproj path per line

steps:
  # Grouped logs render nicely in Azure DevOps
  - powershell: |
      Write-Host "##[group]Environment & Parameters"
      Write-Host "Agent.OS: $env:AGENT_OS"
      Write-Host "Output format: ${{ parameters.outputFormat }}"
      Write-Host "Include license texts: ${{ parameters.includeLicenseTexts }}"
      Write-Host "SBOM output dir: ${{ parameters.sbomOutputDir }}"
      Write-Host "##[endgroup]"
    displayName: Log parameters

  # Node for cyclonedx-npm
  - task: UseNode@1
    displayName: Use Node.js ${{ parameters.nodeVersion }}
    inputs:
      versionSpec: ${{ parameters.nodeVersion }}
      checkLatest: true

  # Install CycloneDX .NET global tool
  - task: PowerShell@2
    displayName: Install CycloneDX .NET tool
    inputs:
      targetType: inline
      script: |
        $ErrorActionPreference = 'Stop'
        Write-Host "##[group]Install CycloneDX .NET tool"

        # Try update first; if it fails (not installed), install.
        dotnet tool update --global CycloneDX
        if ($LASTEXITCODE -ne 0) {
          Write-Host "cyclonedx-dotnet not found; installing..."
          dotnet tool install --global CycloneDX
          if ($LASTEXITCODE -ne 0) { throw "Failed to install CycloneDX .NET tool" }
        }

        $dotnetTools = "$env:USERPROFILE\.dotnet\tools"
        Write-Host "##vso[task.prependpath]$dotnetTools"

        # Log version to confirm install worked
        & "$dotnetTools\cyclonedx" --version

        Write-Host "Installed tools in: $dotnetTools"
        Write-Host "##[endgroup]"

  # Ensure output structure exists
  - powershell: |
      New-Item -ItemType Directory -Path "${{ parameters.sbomOutputDir }}" -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "npm") -Force | Out-Null
      New-Item -ItemType Directory -Path (Join-Path "${{ parameters.sbomOutputDir }}" "dotnet") -Force | Out-Null
    displayName: Prepare output folders

  # npm SBOMs with cyclonedx-npm (no Syft fallback)
  - powershell: |
      Write-Host "##[group]Discover npm projects"
      $rootsParam = @()
      $raw = @'
      ${{ parameters.npmRootsMultiline }}
      '@
      $rootsParam = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' -and -not $_.StartsWith('#') }

      $repoRoot = "$(Build.SourcesDirectory)"
      $projects = @()

      if ($rootsParam.Count -gt 0) {
        foreach ($r in $rootsParam) {
          if (Test-Path (Join-Path $r 'package-lock.json')) {
            $projects += $r
            Write-Host "Root (param): $r"
          } else {
            Write-Warning "No package-lock.json found under: $r (skipped)"
          }
        }
      } else {
        $locks = Get-ChildItem -Path $repoRoot -Recurse -Filter 'package-lock.json' -File
        foreach ($l in $locks) {
          $projects += $l.Directory.FullName
          Write-Host "Root (auto): $($l.Directory.FullName)"
        }
      }
      Write-Host "##[endgroup]"

      $npmOk = 0; $npmFail = 0
      $format = ('${{ parameters.outputFormat }}' -match '(?i)xml') ? 'xml' : 'json'
      $fileExt = $format

      foreach ($proj in $projects) {
        $name = Split-Path $proj -Leaf
        if ([string]::IsNullOrWhiteSpace($name)) { $name = 'app' }
        $safe = ($name -replace '[<>:"/\\|?*]', '-').Trim().TrimEnd('.',' ')
        $outDir = Join-Path "${{ parameters.sbomOutputDir }}" ("npm\" + $safe)
        New-Item -ItemType Directory -Path $outDir -Force | Out-Null
        $outFile = Join-Path $outDir ("$safe-sbom.$fileExt")

        Write-Host "##[group]npm → $proj"
        Push-Location $proj
        try {
          # cyclonedx-npm reads package-lock.json directly
          $args = @('--output-format', $format, '--output-file', $outFile)
          if ('${{ parameters.includeLicenseTexts }}' -eq 'True') { $args += @('--gather-license-texts') }
          npx -y '@cyclonedx/cyclonedx-npm' @args
          if (Test-Path $outFile) { $npmOk++ } else { $npmFail++ }
        } catch {
          Write-Warning "cyclonedx-npm failed: $($_.Exception.Message)"
          $npmFail++
        } finally {
          Pop-Location | Out-Null
          Write-Host "Output: $outFile"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section]npm summary → ok=$npmOk, failed=$npmFail"
      if ($npmFail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some npm SBOMs failed" }
    displayName: Generate npm SBOMs (cyclonedx-npm only)

  # .NET SBOMs with CycloneDX .NET
  - powershell: |
      Write-Host "##[group].NET projects"
      $raw = @'
      ${{ parameters.dotnetProjectsMultiline }}
      '@
      $projPaths = $raw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' -and -not $_.StartsWith('#') }
      $projPaths | ForEach-Object { Write-Host "Path: $_" }
      Write-Host "##[endgroup]"

      if ($projPaths.Count -eq 0) {
        Write-Host "##vso[task.logissue type=warning].NET project list empty; skipping"
        return
      }

      $outDir = Join-Path "${{ parameters.sbomOutputDir }}" "dotnet"
      $format = ('${{ parameters.outputFormat }}' -match '(?i)xml') ? 'Xml' : 'Json'
      $ext = ( $format -eq 'Xml' ) ? 'xml' : 'json'

      $ok = 0; $fail = 0
      foreach ($p in $projPaths) {
        $base = [System.IO.Path]::GetFileNameWithoutExtension($p)
        $fileName = "{0}-sbom.{1}" -f $base, $ext

        Write-Host "##[group].NET → $p"
        try {
          dotnet restore "$p" | Out-Null
          & cyclonedx "$p" -o "$outDir" -F "$format" -fn "$fileName"
          if ($LASTEXITCODE -ne 0) { throw "cyclonedx exit code: $LASTEXITCODE" }
          if (Test-Path (Join-Path $outDir $fileName)) { $ok++ } else { $fail++ }
        } catch {
          Write-Warning "CycloneDX .NET failed: $($_.Exception.Message)"
          $fail++
        } finally {
          Write-Host "Output: $(Join-Path $outDir $fileName)"
          Write-Host "##[endgroup]"
        }
      }

      Write-Host "##[section].NET summary → ok=$ok, failed=$fail"
      if ($fail -gt 0) { Write-Host "##vso[task.logissue type=warning]Some .NET SBOMs failed" }
    displayName: Generate .NET SBOMs (CycloneDX)

  - ${{ if eq(parameters.publishArtifact, true) }}:
      - task: PublishPipelineArtifact@1
        displayName: Publish SBOM artifact
        inputs:
          targetPath: ${{ parameters.sbomOutputDir }}
          publishLocation: pipeline
          artifact: ${{ parameters.artifactName }}
